{
  "language": "Solidity",
  "sources": {
    "src/common/BN256G2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\nimport { IBN256G2 } from \"../interfaces/IBN256G2.sol\";\nimport { ModexpInverse } from \"./BLS.sol\";\n// solhint-disable func-named-parameters\n\n// File lib/core-contracts/contracts/common/BN256G2.sol\n\n/**\n * @title Elliptic curve operations on twist points on bn256 (G2)\n * @dev Adaptation of https://github.com/musalbas/solidity-BN256G2 to 0.6.0 and then 0.8.19\n */\n// slither-disable-next-line missing-inheritance\ncontract BN256G2 is IBN256G2 {\n    uint256 internal constant FIELD_MODULUS = 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47;\n    uint256 internal constant TWISTBX = 0x2b149d40ceb8aaae81be18991be06ac3b5b4c5e559dbefa33267e6dc24a138e5;\n    uint256 internal constant TWISTBY = 0x9713b03af0fed4cd2cafadeed8fdf4a74fa084e52d1852e4a2bd0685c315d2;\n    uint256 internal constant PTXX = 0;\n    uint256 internal constant PTXY = 1;\n    uint256 internal constant PTYX = 2;\n    uint256 internal constant PTYY = 3;\n    uint256 internal constant PTZX = 4;\n    uint256 internal constant PTZY = 5;\n\n    // This is the generator negated, to use for pairing\n    uint256 public constant G2_NEG_X_RE = 0x198E9393920D483A7260BFB731FB5D25F1AA493335A9E71297E485B7AEF312C2;\n    uint256 public constant G2_NEG_X_IM = 0x1800DEEF121F1E76426A00665E5C4479674322D4F75EDADD46DEBD5CD992F6ED;\n    // slither-disable-next-line similar-names\n    uint256 public constant G2_NEG_Y_RE = 0x275dc4a288d1afb3cbb1ac09187524c7db36395df7be3b99e673b13a075a65ec;\n    // slither-disable-next-line similar-names\n    uint256 public constant G2_NEG_Y_IM = 0x1d9befcd05a5323e6da4d435f3b617cdb3af83285c2df711ef39c01571827f9d;\n\n    /**\n     * @notice Add two twist points\n     * @param pt1xx Coefficient 1 of x on point 1\n     * @param pt1xy Coefficient 2 of x on point 1\n     * @param pt1yx Coefficient 1 of y on point 1\n     * @param pt1yy Coefficient 2 of y on point 1\n     * @param pt2xx Coefficient 1 of x on point 2\n     * @param pt2xy Coefficient 2 of x on point 2\n     * @param pt2yx Coefficient 1 of y on point 2\n     * @param pt2yy Coefficient 2 of y on point 2\n     * @return (pt3xx, pt3xy, pt3yx, pt3yy)\n     */\n    function ecTwistAdd(\n        uint256 pt1xx,\n        uint256 pt1xy,\n        uint256 pt1yx,\n        uint256 pt1yy,\n        uint256 pt2xx,\n        uint256 pt2xy,\n        uint256 pt2yx,\n        uint256 pt2yy\n    )\n        external\n        pure\n        returns (uint256, uint256, uint256, uint256)\n    {\n        if (pt1xx == 0 && pt1xy == 0 && pt1yx == 0 && pt1yy == 0) {\n            if (!(pt2xx == 0 && pt2xy == 0 && pt2yx == 0 && pt2yy == 0)) {\n                require(_isOnCurve(pt2xx, pt2xy, pt2yx, pt2yy), \"point not in curve\");\n            }\n            return (pt2xx, pt2xy, pt2yx, pt2yy);\n        } else if (pt2xx == 0 && pt2xy == 0 && pt2yx == 0 && pt2yy == 0) {\n            require(_isOnCurve(pt1xx, pt1xy, pt1yx, pt1yy), \"point not in curve\");\n            return (pt1xx, pt1xy, pt1yx, pt1yy);\n        }\n\n        require(_isOnCurve(pt1xx, pt1xy, pt1yx, pt1yy), \"point not in curve\");\n\n        require(_isOnCurve(pt2xx, pt2xy, pt2yx, pt2yy), \"point not in curve\");\n\n        uint256[6] memory pt3 = ecTwistAddJacobian(pt1xx, pt1xy, pt1yx, pt1yy, 1, 0, pt2xx, pt2xy, pt2yx, pt2yy, 1, 0);\n\n        return _fromJacobian(pt3[PTXX], pt3[PTXY], pt3[PTYX], pt3[PTYY], pt3[PTZX], pt3[PTZY]);\n    }\n\n    /**\n     * @notice Multiply a twist point by a scalar\n     * @param s     Scalar to multiply by\n     * @param pt1xx Coefficient 1 of x\n     * @param pt1xy Coefficient 2 of x\n     * @param pt1yx Coefficient 1 of y\n     * @param pt1yy Coefficient 2 of y\n     * @return (pt2xx, pt2xy, pt2yx, pt2yy)\n     */\n    function ecTwistMul(\n        uint256 s,\n        uint256 pt1xx,\n        uint256 pt1xy,\n        uint256 pt1yx,\n        uint256 pt1yy\n    )\n        external\n        pure\n        returns (uint256, uint256, uint256, uint256)\n    {\n        uint256 pt1zx = 1;\n        if (pt1xx == 0 && pt1xy == 0 && pt1yx == 0 && pt1yy == 0) {\n            pt1xx = 1;\n            pt1yx = 1;\n            pt1zx = 0;\n        } else {\n            require(_isOnCurve(pt1xx, pt1xy, pt1yx, pt1yy), \"point not in curve\");\n        }\n        uint256[6] memory pt2 = _ecTwistMulJacobian(s, pt1xx, pt1xy, pt1yx, pt1yy, pt1zx, 0);\n\n        return _fromJacobian(pt2[PTXX], pt2[PTXY], pt2[PTYX], pt2[PTYY], pt2[PTZX], pt2[PTZY]);\n    }\n\n    /**\n     * @notice Get the field modulus\n     * @return The field modulus\n     */\n    function getFieldModulus() external pure returns (uint256) {\n        return FIELD_MODULUS;\n    }\n\n    /**\n     * @notice a-b mod n\n     * @param a First operand\n     * @param b Second operand\n     * @param n modulus\n     * @return The result of the operation\n     */\n    function submod(uint256 a, uint256 b, uint256 n) internal pure returns (uint256) {\n        return addmod(a, n - b, n);\n    }\n\n    /**\n     * @notice FQ2*FQ2 multiplication operation\n     * @param xx First FQ2 operands first coordinate\n     * @param xy First FQ2 operands second coordinate\n     * @param yx Second FQ2 operands first coordinate\n     * @param yy Second FQ2 operands second coordinate\n     * @return [xx*yx-xy*yy, xx*yy+xy*yx]\n     */\n    function _fq2mul(uint256 xx, uint256 xy, uint256 yx, uint256 yy) internal pure returns (uint256, uint256) {\n        return (\n            submod(mulmod(xx, yx, FIELD_MODULUS), mulmod(xy, yy, FIELD_MODULUS), FIELD_MODULUS),\n            addmod(mulmod(xx, yy, FIELD_MODULUS), mulmod(xy, yx, FIELD_MODULUS), FIELD_MODULUS)\n        );\n    }\n\n    /**\n     * @notice Fq2*k multiplication operation\n     * @param xx FQ2 operands first coordinate\n     * @param xy FQ2 operands second coordinate\n     * @param k scalar to multiply with\n     * @return [xx*k, xy*k]\n     */\n    function _fq2muc(uint256 xx, uint256 xy, uint256 k) internal pure returns (uint256, uint256) {\n        return (mulmod(xx, k, FIELD_MODULUS), mulmod(xy, k, FIELD_MODULUS));\n    }\n\n    /**\n     * @notice FQ2+FQ2 addition operation\n     * @param xx First FQ2 operands first coordinate\n     * @param xy First FQ2 operands second coordinate\n     * @param yx Second FQ2 operands first coordinate\n     * @param yy Second FQ2 operands second coordinate\n     * @return [xx+yx, xy+yy]\n     */\n    // function _fq2add(\n    //     uint256 xx,\n    //     uint256 xy,\n    //     uint256 yx,\n    //     uint256 yy\n    // ) internal pure returns (uint256, uint256) {\n    //     return (addmod(xx, yx, FIELD_MODULUS), addmod(xy, yy, FIELD_MODULUS));\n    // }\n\n    /**\n     * @notice FQ2-FQ2 subtraction operation\n     * @param xx First FQ2 operands first coordinate\n     * @param xy First FQ2 operands second coordinate\n     * @param yx Second FQ2 operands first coordinate\n     * @param yy Second FQ2 operands second coordinate\n     * @return [xx-yx, xy-yy]\n     */\n    function _fq2sub(uint256 xx, uint256 xy, uint256 yx, uint256 yy) internal pure returns (uint256, uint256) {\n        return (submod(xx, yx, FIELD_MODULUS), submod(xy, yy, FIELD_MODULUS));\n    }\n\n    /**\n     * @notice FQ2/FQ2 division operation\n     * @param xx First FQ2 operands first coordinate\n     * @param xy First FQ2 operands second coordinate\n     * @param yx Second FQ2 operands first coordinate\n     * @param yy Second FQ2 operands second coordinate\n     * @return [xx, xy] * Inv([yx, yy])\n     */\n    // function _fq2div(\n    //     uint256 xx,\n    //     uint256 xy,\n    //     uint256 yx,\n    //     uint256 yy\n    // ) internal view returns (uint256, uint256) {\n    //     (yx, yy) = _fq2inv(yx, yy);\n    //     return _fq2mul(xx, xy, yx, yy);\n    // }\n\n    /**\n     * @notice 1/FQ2 inverse operation\n     * @param x FQ2 operands first coordinate\n     * @param y FQ2 operands second coordinate\n     * @return Inv([xx, xy])\n     */\n    // solhint-disable-next-line ordering\n    function _fq2inv(uint256 x, uint256 y) internal pure returns (uint256, uint256) {\n        uint256 inv = ModexpInverse.run(addmod(mulmod(y, y, FIELD_MODULUS), mulmod(x, x, FIELD_MODULUS), FIELD_MODULUS));\n\n        return (mulmod(x, inv, FIELD_MODULUS), FIELD_MODULUS - mulmod(y, inv, FIELD_MODULUS));\n    }\n\n    /**\n     * @notice Checks if FQ2 is on G2\n     * @param xx First FQ2 operands first coordinate\n     * @param xy First FQ2 operands second coordinate\n     * @param yx Second FQ2 operands first coordinate\n     * @param yy Second FQ2 operands second coordinate\n     * @return True if the FQ2 is on G2\n     */\n    function _isOnCurve(uint256 xx, uint256 xy, uint256 yx, uint256 yy) internal pure returns (bool) {\n        uint256 yyx;\n        uint256 yyy;\n        uint256 xxxx;\n        uint256 xxxy;\n        (yyx, yyy) = _fq2mul(yx, yy, yx, yy);\n        (xxxx, xxxy) = _fq2mul(xx, xy, xx, xy);\n        (xxxx, xxxy) = _fq2mul(xxxx, xxxy, xx, xy);\n        (yyx, yyy) = _fq2sub(yyx, yyy, xxxx, xxxy);\n        (yyx, yyy) = _fq2sub(yyx, yyy, TWISTBX, TWISTBY);\n        return yyx == 0 && yyy == 0;\n    }\n\n    /**\n     * @notice Converts a point from jacobian to affine\n     * @param pt1xx First point x real coordinate\n     * @param pt1xy First point x imaginary coordinate\n     * @param pt1yx First point y real coordinate\n     * @param pt1yy First point y imaginary coordinate\n     * @param pt1zx First point z real coordinate\n     * @param pt1zy First point z imaginary coordinate\n     * @return pt2xx (x real affine coordinate)\n     *         pt2xy (x imaginary affine coordinate)\n     *         pt2yx (y real affine coordinate)\n     *         pt1zy (y imaginary affine coordinate)\n     *\n     */\n    function _fromJacobian(\n        uint256 pt1xx,\n        uint256 pt1xy,\n        uint256 pt1yx,\n        uint256 pt1yy,\n        uint256 pt1zx,\n        uint256 pt1zy\n    )\n        internal\n        pure\n        returns (uint256, uint256, uint256, uint256)\n    {\n        uint256 invzx;\n        uint256 invzy;\n        uint256[4] memory pt2;\n        (invzx, invzy) = _fq2inv(pt1zx, pt1zy);\n        (pt2[0], pt2[1]) = _fq2mul(pt1xx, pt1xy, invzx, invzy);\n        (pt2[2], pt2[3]) = _fq2mul(pt1yx, pt1yy, invzx, invzy);\n        return (pt2[0], pt2[1], pt2[2], pt2[3]);\n    }\n\n    /**\n     * @notice Adds two points in jacobian coordinates\n     * @param pt1xx First point x real coordinate\n     * @param pt1xy First point x imaginary coordinate\n     * @param pt1yx First point y real coordinate\n     * @param pt1yy First point y imaginary coordinate\n     * @param pt1zx First point z real coordinate\n     * @param pt1zy First point z imaginary coordinate\n     * @param pt2xx Second point x real coordinate\n     * @param pt2xy Second point x imaginary coordinate\n     * @param pt2yx Second point y real coordinate\n     * @param pt2yy Second point y imaginary coordinate\n     * @param pt2zx Second point z real coordinate\n     * @param pt2zy Second point z imaginary coordinate\n     * @return pt3 = pt1+pt2 in jacobian\n     *\n     */\n    function ecTwistAddJacobian(\n        uint256 pt1xx,\n        uint256 pt1xy,\n        uint256 pt1yx,\n        uint256 pt1yy,\n        uint256 pt1zx,\n        uint256 pt1zy,\n        uint256 pt2xx,\n        uint256 pt2xy,\n        uint256 pt2yx,\n        uint256 pt2yy,\n        uint256 pt2zx,\n        uint256 pt2zy\n    )\n        internal\n        pure\n        returns (uint256[6] memory pt3)\n    {\n        if (pt1zx == 0 && pt1zy == 0) {\n            (pt3[PTXX], pt3[PTXY], pt3[PTYX], pt3[PTYY], pt3[PTZX], pt3[PTZY]) =\n                (pt2xx, pt2xy, pt2yx, pt2yy, pt2zx, pt2zy);\n            return pt3;\n        } else if (pt2zx == 0 && pt2zy == 0) {\n            (pt3[PTXX], pt3[PTXY], pt3[PTYX], pt3[PTYY], pt3[PTZX], pt3[PTZY]) =\n                (pt1xx, pt1xy, pt1yx, pt1yy, pt1zx, pt1zy);\n            return pt3;\n        }\n\n        (pt2yx, pt2yy) = _fq2mul(pt2yx, pt2yy, pt1zx, pt1zy); // U1 = y2 * z1\n        (pt3[PTYX], pt3[PTYY]) = _fq2mul(pt1yx, pt1yy, pt2zx, pt2zy); // U2 = y1 * z2\n        (pt2xx, pt2xy) = _fq2mul(pt2xx, pt2xy, pt1zx, pt1zy); // V1 = x2 * z1\n        (pt3[PTZX], pt3[PTZY]) = _fq2mul(pt1xx, pt1xy, pt2zx, pt2zy); // V2 = x1 * z2\n\n        if (pt2xx == pt3[PTZX] && pt2xy == pt3[PTZY]) {\n            if (pt2yx == pt3[PTYX] && pt2yy == pt3[PTYY]) {\n                (pt3[PTXX], pt3[PTXY], pt3[PTYX], pt3[PTYY], pt3[PTZX], pt3[PTZY]) =\n                    _ecTwistDoubleJacobian(pt1xx, pt1xy, pt1yx, pt1yy, pt1zx, pt1zy);\n                return pt3;\n            }\n            (pt3[PTXX], pt3[PTXY], pt3[PTYX], pt3[PTYY], pt3[PTZX], pt3[PTZY]) = (1, 0, 1, 0, 0, 0);\n            return pt3;\n        }\n\n        (pt2zx, pt2zy) = _fq2mul(pt1zx, pt1zy, pt2zx, pt2zy); // W = z1 * z2\n        (pt1xx, pt1xy) = _fq2sub(pt2yx, pt2yy, pt3[PTYX], pt3[PTYY]); // U = U1 - U2\n        (pt1yx, pt1yy) = _fq2sub(pt2xx, pt2xy, pt3[PTZX], pt3[PTZY]); // V = V1 - V2\n        (pt1zx, pt1zy) = _fq2mul(pt1yx, pt1yy, pt1yx, pt1yy); // V_squared = V * V\n        (pt2yx, pt2yy) = _fq2mul(pt1zx, pt1zy, pt3[PTZX], pt3[PTZY]); // V_squared_times_V2 = V_squared * V2\n        (pt1zx, pt1zy) = _fq2mul(pt1zx, pt1zy, pt1yx, pt1yy); // V_cubed = V * V_squared\n        (pt3[PTZX], pt3[PTZY]) = _fq2mul(pt1zx, pt1zy, pt2zx, pt2zy); // newz = V_cubed * W\n        (pt2xx, pt2xy) = _fq2mul(pt1xx, pt1xy, pt1xx, pt1xy); // U * U\n        (pt2xx, pt2xy) = _fq2mul(pt2xx, pt2xy, pt2zx, pt2zy); // U * U * W\n        (pt2xx, pt2xy) = _fq2sub(pt2xx, pt2xy, pt1zx, pt1zy); // U * U * W - V_cubed\n        (pt2zx, pt2zy) = _fq2muc(pt2yx, pt2yy, 2); // 2 * V_squared_times_V2\n        (pt2xx, pt2xy) = _fq2sub(pt2xx, pt2xy, pt2zx, pt2zy); // A = U * U * W - V_cubed - 2 * V_squared_times_V2\n        (pt3[PTXX], pt3[PTXY]) = _fq2mul(pt1yx, pt1yy, pt2xx, pt2xy); // newx = V * A\n        (pt1yx, pt1yy) = _fq2sub(pt2yx, pt2yy, pt2xx, pt2xy); // V_squared_times_V2 - A\n        (pt1yx, pt1yy) = _fq2mul(pt1xx, pt1xy, pt1yx, pt1yy); // U * (V_squared_times_V2 - A)\n        (pt1xx, pt1xy) = _fq2mul(pt1zx, pt1zy, pt3[PTYX], pt3[PTYY]); // V_cubed * U2\n        (pt3[PTYX], pt3[PTYY]) = _fq2sub(pt1yx, pt1yy, pt1xx, pt1xy); // newy = U * (V_squared_times_V2 - A) - V_cubed\n            // *\n            // U2\n    }\n\n    /**\n     * @notice Doubls a point in jacobian coordinates\n     * @param pt1xx Point x real coordinate\n     * @param pt1xy Point x imaginary coordinate\n     * @param pt1yx Point y real coordinate\n     * @param pt1yy Point y imaginary coordinate\n     * @param pt1zx Point z real coordinate\n     * @param pt1zy Point z imaginary coordinate\n     * @return pt2xx, pt2xy, pt2yx, pt2yy, pt2zx, pt2zy the coordinates of pt2 = 2*pt1\n     *\n     */\n    function _ecTwistDoubleJacobian(\n        uint256 pt1xx,\n        uint256 pt1xy,\n        uint256 pt1yx,\n        uint256 pt1yy,\n        uint256 pt1zx,\n        uint256 pt1zy\n    )\n        internal\n        pure\n        returns (uint256, uint256, uint256, uint256, uint256, uint256)\n    {\n        uint256[6] memory pt2;\n        (pt2[0], pt2[1]) = _fq2muc(pt1xx, pt1xy, 3); // 3 * x\n        (pt2[0], pt2[1]) = _fq2mul(pt2[0], pt2[1], pt1xx, pt1xy); // W = 3 * x * x\n        (pt1zx, pt1zy) = _fq2mul(pt1yx, pt1yy, pt1zx, pt1zy); // S = y * z\n        (pt2[2], pt2[3]) = _fq2mul(pt1xx, pt1xy, pt1yx, pt1yy); // x * y\n        (pt2[2], pt2[3]) = _fq2mul(pt2[2], pt2[3], pt1zx, pt1zy); // B = x * y * S\n        (pt1xx, pt1xy) = _fq2mul(pt2[0], pt2[1], pt2[0], pt2[1]); // W * W\n        (pt2[4], pt2[5]) = _fq2muc(pt2[2], pt2[3], 8); // 8 * B\n        (pt1xx, pt1xy) = _fq2sub(pt1xx, pt1xy, pt2[4], pt2[5]); // H = W * W - 8 * B\n        (pt2[4], pt2[5]) = _fq2mul(pt1zx, pt1zy, pt1zx, pt1zy); // S_squared = S * S\n        (pt2[2], pt2[3]) = _fq2muc(pt2[2], pt2[3], 4); // 4 * B\n        (pt2[2], pt2[3]) = _fq2sub(pt2[2], pt2[3], pt1xx, pt1xy); // 4 * B - H\n        (pt2[2], pt2[3]) = _fq2mul(pt2[2], pt2[3], pt2[0], pt2[1]); // W * (4 * B - H)\n        (pt2[0], pt2[1]) = _fq2muc(pt1yx, pt1yy, 8); // 8 * y\n        (pt2[0], pt2[1]) = _fq2mul(pt2[0], pt2[1], pt1yx, pt1yy); // 8 * y * y\n        (pt2[0], pt2[1]) = _fq2mul(pt2[0], pt2[1], pt2[4], pt2[5]); // 8 * y * y * S_squared\n        (pt2[2], pt2[3]) = _fq2sub(pt2[2], pt2[3], pt2[0], pt2[1]); // newy = W * (4 * B - H) - 8 * y * y * S_squared\n        (pt2[0], pt2[1]) = _fq2muc(pt1xx, pt1xy, 2); // 2 * H\n        (pt2[0], pt2[1]) = _fq2mul(pt2[0], pt2[1], pt1zx, pt1zy); // newx = 2 * H * S\n        (pt2[4], pt2[5]) = _fq2mul(pt1zx, pt1zy, pt2[4], pt2[5]); // S * S_squared\n        (pt2[4], pt2[5]) = _fq2muc(pt2[4], pt2[5], 8); // newz = 8 * S * S_squared\n\n        return (pt2[0], pt2[1], pt2[2], pt2[3], pt2[4], pt2[5]);\n    }\n\n    /**\n     * @notice Doubls a point in jacobian coordinates\n     * @param d scalar to multiply the point with\n     * @param pt1xx Point x real coordinate\n     * @param pt1xy Point x imaginary coordinate\n     * @param pt1yx Point y real coordinate\n     * @param pt1yy Point y imaginary coordinate\n     * @param pt1zx Point z real coordinate\n     * @param pt1zy Point z imaginary coordinate\n     * @return pt2 a point representing pt2 = d*pt1 in jacobian coordinates\n     *\n     */\n    function _ecTwistMulJacobian(\n        uint256 d,\n        uint256 pt1xx,\n        uint256 pt1xy,\n        uint256 pt1yx,\n        uint256 pt1yy,\n        uint256 pt1zx,\n        uint256 pt1zy\n    )\n        internal\n        pure\n        returns (uint256[6] memory pt2)\n    {\n        while (d != 0) {\n            if ((d & 1) != 0) {\n                pt2 = ecTwistAddJacobian(\n                    pt2[PTXX],\n                    pt2[PTXY],\n                    pt2[PTYX],\n                    pt2[PTYY],\n                    pt2[PTZX],\n                    pt2[PTZY],\n                    pt1xx,\n                    pt1xy,\n                    pt1yx,\n                    pt1yy,\n                    pt1zx,\n                    pt1zy\n                );\n            }\n            (pt1xx, pt1xy, pt1yx, pt1yy, pt1zx, pt1zy) =\n                _ecTwistDoubleJacobian(pt1xx, pt1xy, pt1yx, pt1yy, pt1zx, pt1zy);\n\n            d = d / 2;\n        }\n        return pt2;\n    }\n}\n"
    },
    "src/interfaces/IBN256G2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\ninterface IBN256G2 {\n    function ecTwistAdd(\n        uint256 pt1xx,\n        uint256 pt1xy,\n        uint256 pt1yx,\n        uint256 pt1yy,\n        uint256 pt2xx,\n        uint256 pt2xy,\n        uint256 pt2yx,\n        uint256 pt2yy\n    )\n        external\n        view\n        returns (uint256, uint256, uint256, uint256);\n}\n"
    },
    "src/common/BLS.sol": {
      "content": "// Sources flattened with hardhat v2.19.1 https://hardhat.org\n\n// SPDX-License-Identifier: MIT\n\n// File lib/core-contracts/contracts/interfaces/common/IBLS.sol\n\n// Original license: SPDX_License_Identifier: MIT\npragma solidity 0.8.25;\n\nimport { IBLS } from \"../interfaces/IBLS.sol\";\n// File lib/core-contracts/contracts/lib/ModExp.sol\n\n// Original license: SPDX_License_Identifier: MIT\n\n/* MIT License\n\nCopyright (c) 2021 Hubble-Project\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n/**\n * @title Compute Inverse by Modular Exponentiation\n *     @notice Compute $input^(N - 2) mod N$ using Addition Chain method.\n *     Where     N = 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n *     and   N - 2 = 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd45\n *     @dev the function body is generated with the modified addchain script\n *     see https://github.com/kobigurk/addchain/commit/2c37a2ace567a9bdc680b4e929c94aaaa3ec700f\n */\nlibrary ModexpInverse {\n    /**\n     * @notice computes inverse\n     * @dev computes $input^(N - 2) mod N$ using Addition Chain method.\n     * @param t2 the number to get the inverse of (uint256)\n     * @return t0 the inverse (uint256)\n     */\n    function run(uint256 t2) internal pure returns (uint256 t0) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let n := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n            t0 := mulmod(t2, t2, n)\n            let t5 := mulmod(t0, t2, n)\n            let t1 := mulmod(t5, t0, n)\n            let t3 := mulmod(t5, t5, n)\n            let t8 := mulmod(t1, t0, n)\n            let t4 := mulmod(t3, t5, n)\n            let t6 := mulmod(t3, t1, n)\n            t0 := mulmod(t3, t3, n)\n            let t7 := mulmod(t8, t3, n)\n            t3 := mulmod(t4, t3, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t5, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t2, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t2, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t8, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t8, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t2, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t8, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t2, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t5, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t7, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t1, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t5, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t8, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t1, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t2, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t6, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t7, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t1, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t5, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t1, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t5, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t6, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t6, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t1, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t8, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t6, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t1, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t4, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t6, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t2, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t8, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t8, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t1, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t2, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t7, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t3, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t2, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t2, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t5, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t6, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t5, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t5, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t3, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t4, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t3, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t1, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t2, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t1, n)\n        }\n    }\n}\n\n/**\n * @title Compute Square Root by Modular Exponentiation\n *     @notice Compute $input^{(N + 1) / 4} mod N$ using Addition Chain method.\n *     Where           N = 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n *     and   (N + 1) / 4 = 0xc19139cb84c680a6e14116da060561765e05aa45a1c72a34f082305b61f3f52\n */\nlibrary ModexpSqrt {\n    /**\n     * @notice computes square root by modular exponentiation\n     * @dev Compute $input^{(N + 1) / 4} mod N$ using Addition Chain method\n     * @param t6 the number to derive the square root of\n     * @return t0 the square root\n     */\n    function run(uint256 t6) internal pure returns (uint256 t0) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let n := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\n\n            t0 := mulmod(t6, t6, n)\n            let t4 := mulmod(t0, t6, n)\n            let t2 := mulmod(t4, t0, n)\n            let t3 := mulmod(t4, t4, n)\n            let t8 := mulmod(t2, t0, n)\n            let t1 := mulmod(t3, t4, n)\n            let t5 := mulmod(t3, t2, n)\n            t0 := mulmod(t3, t3, n)\n            let t7 := mulmod(t8, t3, n)\n            t3 := mulmod(t1, t3, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t4, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t6, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t6, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t8, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t8, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t6, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t8, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t6, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t4, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t7, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t2, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t4, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t8, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t2, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t6, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t5, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t7, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t2, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t4, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t2, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t4, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t5, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t5, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t2, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t8, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t5, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t2, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t1, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t5, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t6, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t8, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t8, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t2, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t6, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t7, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t3, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t6, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t6, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t4, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t5, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t4, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t4, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t3, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t1, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t3, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t2, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t0, n)\n            t0 := mulmod(t0, t1, n)\n            t0 := mulmod(t0, t0, n)\n        }\n    }\n}\n\n// File lib/core-contracts/contracts/common/BLS.sol\n\n// Original license: SPDX_License_Identifier: MIT\n\n/* MIT License\n\nCopyright (c) 2021 Hubble-Project (natspec added by Polygon Technology)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n/**\n * @title  Boneh–Lynn–Shacham (BLS) signature scheme on Barreto-Naehrig 254 bit curve (BN-254)\n *     @notice BLS signature aggregation reduces the size of signature data to store on-chain\n *     @dev points on G1 are used for signatures and messages, and on G2 for public keys\n */\ncontract BLS is IBLS {\n    // Field order\n    // prettier-ignore\n    uint256 private constant N =\n        21_888_242_871_839_275_222_246_405_745_257_275_088_696_311_157_297_823_662_689_037_894_645_226_208_583;\n\n    // Negated generator of G2\n    // prettier-ignore\n    uint256 private constant N_G2_X1 =\n        11_559_732_032_986_387_107_991_004_021_392_285_783_925_812_861_821_192_530_917_403_151_452_391_805_634;\n    // prettier-ignore\n    uint256 private constant N_G2_X0 =\n        10_857_046_999_023_057_135_944_570_762_232_829_481_370_756_359_578_518_086_990_519_993_285_655_852_781;\n    // prettier-ignore\n    uint256 private constant N_G2_Y1 =\n        17_805_874_995_975_841_540_914_202_342_111_839_520_379_459_829_704_422_454_583_296_818_431_106_115_052;\n    // prettier-ignore\n    uint256 private constant N_G2_Y0 =\n        13_392_588_948_715_843_804_641_432_497_768_002_650_278_120_570_034_223_513_918_757_245_338_268_106_653;\n    // slither-disable-start too-many-digits\n    // sqrt(-3)\n    // prettier-ignore\n    uint256 private constant Z0 = 0x0000000000000000b3c4d79d41a91759a9e4c7e359b6b89eaec68e62effffffd;\n    // (sqrt(-3) - 1)  / 2\n    // prettier-ignore\n    uint256 private constant Z1 = 0x000000000000000059e26bcea0d48bacd4f263f1acdb5c4f5763473177fffffe;\n\n    // prettier-ignore\n    uint256 private constant T24 = 0x1000000000000000000000000000000000000000000000000;\n    // slither-disable-end too-many-digits\n\n    // prettier-ignore\n    uint256 private constant MASK24 = 0xffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /**\n     * @inheritdoc IBLS\n     */\n    function verifySingle(\n        uint256[2] calldata signature,\n        uint256[4] calldata pubkey,\n        uint256[2] calldata message\n    )\n        external\n        view\n        returns (bool, bool)\n    {\n        uint256[12] memory input = [\n            signature[0],\n            signature[1],\n            N_G2_X1,\n            N_G2_X0,\n            N_G2_Y1,\n            N_G2_Y0,\n            message[0],\n            message[1],\n            pubkey[1],\n            pubkey[0],\n            pubkey[3],\n            pubkey[2]\n        ];\n        uint256[1] memory out;\n\n        bool callSuccess;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            callSuccess := staticcall(gas(), 8, input, 384, out, 0x20)\n        }\n        if (!callSuccess) {\n            return (false, false);\n        }\n        return (out[0] != 0, true);\n    }\n\n    /**\n     * @inheritdoc IBLS\n     */\n    function verifyMultiple(\n        uint256[2] calldata signature,\n        uint256[4][] calldata pubkeys,\n        uint256[2][] calldata messages\n    )\n        external\n        view\n        returns (bool checkResult, bool callSuccess)\n    {\n        uint256 size = pubkeys.length;\n        // solhint-disable-next-line reason-string\n        require(size > 0, \"BLS: number of public key is zero\");\n        // solhint-disable-next-line reason-string\n        require(size == messages.length, \"BLS: number of public keys and messages must be equal\");\n        uint256 inputSize = (size + 1) * 6;\n        uint256[] memory input = new uint256[](inputSize);\n        input[0] = signature[0];\n        input[1] = signature[1];\n        input[2] = N_G2_X1;\n        input[3] = N_G2_X0;\n        input[4] = N_G2_Y1;\n        input[5] = N_G2_Y0;\n        for (uint256 i = 0; i < size; i++) {\n            input[i * 6 + 6] = messages[i][0];\n            input[i * 6 + 7] = messages[i][1];\n            input[i * 6 + 8] = pubkeys[i][1];\n            input[i * 6 + 9] = pubkeys[i][0];\n            input[i * 6 + 10] = pubkeys[i][3];\n            input[i * 6 + 11] = pubkeys[i][2];\n        }\n        uint256[1] memory out;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            callSuccess := staticcall(gas(), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\n        }\n        if (!callSuccess) {\n            return (false, false);\n        }\n        return (out[0] != 0, true);\n    }\n\n    /**\n     * @inheritdoc IBLS\n     */\n    function verifyMultipleSameMsg(\n        uint256[2] calldata signature,\n        uint256[4][] calldata pubkeys,\n        uint256[2] calldata message\n    )\n        external\n        view\n        returns (bool checkResult, bool callSuccess)\n    {\n        uint256 size = pubkeys.length;\n        // solhint-disable-next-line reason-string\n        require(size > 0, \"BLS: number of public key is zero\");\n        uint256 inputSize = (size + 1) * 6;\n        uint256[] memory input = new uint256[](inputSize);\n        input[0] = signature[0];\n        input[1] = signature[1];\n        input[2] = N_G2_X1;\n        input[3] = N_G2_X0;\n        input[4] = N_G2_Y1;\n        input[5] = N_G2_Y0;\n        for (uint256 i = 0; i < size; i++) {\n            input[i * 6 + 6] = message[0];\n            input[i * 6 + 7] = message[1];\n            input[i * 6 + 8] = pubkeys[i][1];\n            input[i * 6 + 9] = pubkeys[i][0];\n            input[i * 6 + 10] = pubkeys[i][3];\n            input[i * 6 + 11] = pubkeys[i][2];\n        }\n        uint256[1] memory out;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            callSuccess := staticcall(gas(), 8, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)\n        }\n        if (!callSuccess) {\n            return (false, false);\n        }\n        return (out[0] != 0, true);\n    }\n\n    /**\n     * @inheritdoc IBLS\n     */\n    function hashToPoint(bytes32 domain, bytes memory message) external view returns (uint256[2] memory) {\n        uint256[2] memory u = this.hashToField(domain, message);\n        uint256[2] memory p0 = this.mapToPoint(u[0]);\n        uint256[2] memory p1 = this.mapToPoint(u[1]);\n        uint256[4] memory bnAddInput;\n        bnAddInput[0] = p0[0];\n        bnAddInput[1] = p0[1];\n        bnAddInput[2] = p1[0];\n        bnAddInput[3] = p1[1];\n        bool success;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            success := staticcall(sub(gas(), 2000), 6, bnAddInput, 128, p0, 64)\n            switch success\n            case 0 { invalid() }\n        }\n        require(success, \"BLS: bn add call failed\");\n        return p0;\n    }\n\n    /**\n     * @inheritdoc IBLS\n     */\n    function mapToPoint(uint256 _x) external pure returns (uint256[2] memory p) {\n        // solhint-disable-next-line reason-string\n        require(_x < N, \"mapToPointFT: invalid field element\");\n        uint256 x = _x;\n\n        (, bool decision) = sqrt(x);\n\n        uint256 a0 = mulmod(x, x, N);\n        a0 = addmod(a0, 4, N);\n        uint256 a1 = mulmod(x, Z0, N);\n        uint256 a2 = mulmod(a1, a0, N);\n        a2 = inverse(a2);\n        a1 = mulmod(a1, a1, N);\n        a1 = mulmod(a1, a2, N);\n\n        // x1\n        a1 = mulmod(x, a1, N);\n        x = addmod(Z1, N - a1, N);\n        // check curve\n        a1 = mulmod(x, x, N);\n        a1 = mulmod(a1, x, N);\n        a1 = addmod(a1, 3, N);\n        bool found;\n        (a1, found) = sqrt(a1);\n        if (found) {\n            if (!decision) {\n                a1 = N - a1;\n            }\n            return [x, a1];\n        }\n\n        // x2\n        x = N - addmod(x, 1, N);\n        // check curve\n        a1 = mulmod(x, x, N);\n        a1 = mulmod(a1, x, N);\n        a1 = addmod(a1, 3, N);\n        (a1, found) = sqrt(a1);\n        if (found) {\n            if (!decision) {\n                a1 = N - a1;\n            }\n            return [x, a1];\n        }\n\n        // x3\n        x = mulmod(a0, a0, N);\n        x = mulmod(x, x, N);\n        x = mulmod(x, a2, N);\n        x = mulmod(x, a2, N);\n        x = addmod(x, 1, N);\n        // must be on curve\n        a1 = mulmod(x, x, N);\n        a1 = mulmod(a1, x, N);\n        a1 = addmod(a1, 3, N);\n        (a1, found) = sqrt(a1);\n        // solhint-disable-next-line reason-string\n        require(found, \"BLS: bad ft mapping implementation\");\n        if (!decision) {\n            a1 = N - a1;\n        }\n        return [x, a1];\n    }\n\n    /**\n     * @inheritdoc IBLS\n     */\n    // solhint-disable-next-line ordering\n    function isValidSignature(uint256[2] memory signature) external view returns (bool) {\n        if ((signature[0] >= N) || (signature[1] >= N)) {\n            return false;\n        } else {\n            return this.isOnCurveG1(signature);\n        }\n    }\n\n    /**\n     * @inheritdoc IBLS\n     */\n    function isOnCurveG1(uint256[2] memory point) external pure returns (bool _isOnCurve) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let t0 := mload(point)\n            let t1 := mload(add(point, 32))\n            let t2 := mulmod(t0, t0, N)\n            t2 := mulmod(t2, t0, N)\n            t2 := addmod(t2, 3, N)\n            t1 := mulmod(t1, t1, N)\n            _isOnCurve := eq(t1, t2)\n        }\n    }\n\n    /**\n     * @inheritdoc IBLS\n     */\n    function isOnCurveG2(uint256[4] memory point) external pure returns (bool _isOnCurve) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // x0, x1\n            let t0 := mload(point)\n            let t1 := mload(add(point, 32))\n            // x0 ^ 2\n            let t2 := mulmod(t0, t0, N)\n            // x1 ^ 2\n            let t3 := mulmod(t1, t1, N)\n            // 3 * x0 ^ 2\n            let t4 := add(add(t2, t2), t2)\n            // 3 * x1 ^ 2\n            let t5 := addmod(add(t3, t3), t3, N)\n            // x0 * (x0 ^ 2 - 3 * x1 ^ 2)\n            t2 := mulmod(add(t2, sub(N, t5)), t0, N)\n            // x1 * (3 * x0 ^ 2 - x1 ^ 2)\n            t3 := mulmod(add(t4, sub(N, t3)), t1, N)\n\n            // x ^ 3 + b\n            t0 := addmod(t2, 0x2b149d40ceb8aaae81be18991be06ac3b5b4c5e559dbefa33267e6dc24a138e5, N)\n            t1 := addmod(t3, 0x009713b03af0fed4cd2cafadeed8fdf4a74fa084e52d1852e4a2bd0685c315d2, N)\n\n            // y0, y1\n            t2 := mload(add(point, 64))\n            t3 := mload(add(point, 96))\n            // y ^ 2\n            t4 := mulmod(addmod(t2, t3, N), addmod(t2, sub(N, t3), N), N)\n            t3 := mulmod(shl(1, t2), t3, N)\n\n            // y ^ 2 == x ^ 3 + b\n            _isOnCurve := and(eq(t0, t4), eq(t1, t3))\n        }\n    }\n\n    /**\n     * @notice returns square root of a uint256 value\n     * @param xx the value to take the square root of\n     * @return x the uint256 value of the root\n     * @return hasRoot a bool indicating if there is a square root\n     */\n    function sqrt(uint256 xx) internal pure returns (uint256 x, bool hasRoot) {\n        x = ModexpSqrt.run(xx);\n        hasRoot = mulmod(x, x, N) == xx;\n    }\n\n    /**\n     * @notice inverts a uint256 value\n     * @param a uint256 value to invert\n     * @return uint256 of the value of the inverse\n     */\n    function inverse(uint256 a) internal pure returns (uint256) {\n        return ModexpInverse.run(a);\n    }\n\n    /**\n     * @inheritdoc IBLS\n     */\n    function hashToField(bytes32 domain, bytes memory messages) external view returns (uint256[2] memory) {\n        bytes memory _msg = this.expandMsgTo96(domain, messages);\n        uint256 u0;\n        uint256 u1;\n        uint256 a0;\n        uint256 a1;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let p := add(_msg, 24)\n            u1 := and(mload(p), MASK24)\n            p := add(_msg, 48)\n            u0 := and(mload(p), MASK24)\n            a0 := addmod(mulmod(u1, T24, N), u0, N)\n            p := add(_msg, 72)\n            u1 := and(mload(p), MASK24)\n            p := add(_msg, 96)\n            u0 := and(mload(p), MASK24)\n            a1 := addmod(mulmod(u1, T24, N), u0, N)\n        }\n        return [a0, a1];\n    }\n\n    /**\n     * @inheritdoc IBLS\n     */\n    function expandMsgTo96(bytes32 domain, bytes memory message) external pure returns (bytes memory) {\n        // zero<64>|msg<var>|lib_str<2>|I2OSP(0, 1)<1>|dst<var>|dst_len<1>\n        uint256 t0 = message.length;\n        bytes memory msg0 = new bytes(32 + t0 + 64 + 4);\n        bytes memory out = new bytes(96);\n        // b0\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let p := add(msg0, 96)\n            for { let z := 0 } lt(z, t0) { z := add(z, 32) } { mstore(add(p, z), mload(add(message, add(z, 32)))) }\n            p := add(p, t0)\n\n            mstore8(p, 0)\n            p := add(p, 1)\n            mstore8(p, 96)\n            p := add(p, 1)\n            mstore8(p, 0)\n            p := add(p, 1)\n\n            mstore(p, domain)\n            p := add(p, 32)\n            mstore8(p, 32)\n        }\n        bytes32 b0 = sha256(msg0);\n        bytes32 bi;\n        t0 = 32 + 34;\n\n        // resize intermediate message\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(msg0, t0)\n        }\n\n        // b1\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(add(msg0, 32), b0)\n            mstore8(add(msg0, 64), 1)\n            mstore(add(msg0, 65), domain)\n            mstore8(add(msg0, add(32, 65)), 32)\n        }\n\n        bi = sha256(msg0);\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(add(out, 32), bi)\n        }\n\n        // b2\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let t := xor(b0, bi)\n            mstore(add(msg0, 32), t)\n            mstore8(add(msg0, 64), 2)\n            mstore(add(msg0, 65), domain)\n            mstore8(add(msg0, add(32, 65)), 32)\n        }\n\n        bi = sha256(msg0);\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(add(out, 64), bi)\n        }\n\n        // b3\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let t := xor(b0, bi)\n            mstore(add(msg0, 32), t)\n            mstore8(add(msg0, 64), 3)\n            mstore(add(msg0, 65), domain)\n            mstore8(add(msg0, add(32, 65)), 32)\n        }\n\n        bi = sha256(msg0);\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(add(out, 96), bi)\n        }\n\n        return out;\n    }\n}\n"
    },
    "src/interfaces/IBLS.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\ninterface IBLS {\n    /**\n     * @notice verifies a single signature\n     * @param signature 64-byte G1 group element (small sig)\n     * @param pubkey 128-byte G2 group element (big pubkey)\n     * @param message message signed to produce signature\n     * @return bool sig verification\n     * @return bool indicating call success\n     */\n    function verifySingle(\n        uint256[2] calldata signature,\n        uint256[4] calldata pubkey,\n        uint256[2] calldata message\n    )\n        external\n        view\n        returns (bool, bool);\n\n    /**\n     * @notice verifies multiple non-aggregated signatures where each message is unique\n     * @param signature 64-byte G1 group element (small sig)\n     * @param pubkeys array of 128-byte G2 group element (big pubkey)\n     * @param messages array of messages signed to produce signature\n     * @return checkResult bool indicating sig verification\n     * @return callSuccess bool indicating call success\n     */\n    function verifyMultiple(\n        uint256[2] calldata signature,\n        uint256[4][] calldata pubkeys,\n        uint256[2][] calldata messages\n    )\n        external\n        view\n        returns (bool checkResult, bool callSuccess);\n\n    /**\n     * @notice verifies an aggregated signature where the same message is signed\n     * @param signature 64-byte G1 group element (small sig)\n     * @param pubkeys array of 128-byte G2 group element (big pubkey)\n     * @param message message signed by all to produce signature\n     * @return checkResult sig verification\n     * @return callSuccess indicating call success\n     */\n    function verifyMultipleSameMsg(\n        uint256[2] calldata signature,\n        uint256[4][] calldata pubkeys,\n        uint256[2] calldata message\n    )\n        external\n        view\n        returns (bool checkResult, bool callSuccess);\n\n    /**\n     * @notice checks if a signature is formatted correctly and valid\n     * @dev will revert if improperly formatted, will return false if invalid\n     * @param signature the BLS signature\n     * @return bool indicating if the signature is valid or not\n     */\n    function isValidSignature(uint256[2] memory signature) external view returns (bool);\n\n    /**\n     * @notice hashes an arbitrary message to a point on the curve\n     * @dev Fouque-Tibouchi Hash to Curve\n     * @param domain domain separator for the hash\n     * @param message the message to map\n     * @return uint256[2] (x,y) point on the curve that the message maps to\n     */\n    function hashToPoint(bytes32 domain, bytes memory message) external view returns (uint256[2] memory);\n\n    /**\n     * @notice hashes an arbitrary message to a field element\n     * @param domain domain separator for the hash\n     * @param messages the messages to map\n     * @return uint256[2] (x,y) point of the field element that the message maps to\n     */\n    function hashToField(bytes32 domain, bytes memory messages) external view returns (uint256[2] memory);\n\n    /**\n     * @notice maps a field element to the curve\n     * @param _x a valid field element\n     * @return p the point on the curve the point is mapped to\n     */\n    function mapToPoint(uint256 _x) external pure returns (uint256[2] memory p);\n\n    /**\n     * @notice checks if point in the finite field Fq (x,y) is on the G1 curve\n     * @param point array with x and y values of the point\n     * @return _isOnCurve bool indicating if the point is on the curve or not\n     */\n    function isOnCurveG1(uint256[2] memory point) external pure returns (bool _isOnCurve);\n\n    /**\n     * @notice checks if point in the finite field Fq (x,y) is on the G2 curve\n     * @param point array with x and y values of the point\n     * @return _isOnCurve bool indicating if the point is on the curve or not\n     */\n    function isOnCurveG2(uint256[4] memory point) external pure returns (bool _isOnCurve);\n\n    /**\n     * @notice pads messages less than 96 bytes to 96 bytes for hashing\n     * @param domain domain separator for the hash\n     * @param message the message to pad\n     * @return bytes the padded message\n     */\n    function expandMsgTo96(bytes32 domain, bytes memory message) external pure returns (bytes memory);\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
      "@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",
      "ds-test/=lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/",
      "erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/",
      "openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/",
      "openzeppelin-foundry-upgrades/=lib/openzeppelin-foundry-upgrades/src/",
      "solidity-stringutils/=lib/openzeppelin-foundry-upgrades/lib/solidity-stringutils/"
    ],
    "optimizer": { "enabled": true, "runs": 10000 },
    "metadata": { "useLiteralContent": false, "bytecodeHash": "none", "appendCBOR": true },
    "outputSelection": {
      "*": {
        "": ["ast"],
        "*": ["abi", "evm.bytecode", "evm.deployedBytecode", "evm.methodIdentifiers", "metadata", "storageLayout"]
      }
    },
    "evmVersion": "paris",
    "viaIR": false,
    "libraries": {}
  }
}
