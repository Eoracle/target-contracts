{
  "language": "Solidity",
  "sources": {
    "src/EOFeedVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { IEOFeedVerifier } from \"./interfaces/IEOFeedVerifier.sol\";\nimport { Merkle } from \"./common/Merkle.sol\";\nimport {\n    CallerIsNotFeedManager,\n    InvalidProof,\n    InvalidAddress,\n    InvalidEventRoot,\n    VotingPowerIsZero,\n    AggVotingPowerIsZero,\n    InsufficientVotingPower,\n    SignatureVerificationFailed,\n    ValidatorIndexOutOfBounds,\n    SenderNotAllowed,\n    ValidatorSetTooSmall\n} from \"./interfaces/Errors.sol\";\nimport { IBLS } from \"./interfaces/IBLS.sol\";\nimport { IBN256G2 } from \"./interfaces/IBN256G2.sol\";\n\nusing Merkle for bytes32;\n\n/**\n * @title EOFeedManager\n * @notice The EOFeedVerifier contract handles the verification of update payloads. The payload includes a Merkle root\n * signed by eoracle validators and a Merkle path to the leaf containing the data. The verifier stores the current\n * validator set in its storage and ensures that the Merkle root is signed by a subset of this validator set with\n * sufficient voting power.\n */\ncontract EOFeedVerifier is IEOFeedVerifier, OwnableUpgradeable {\n    bytes32 public constant DOMAIN = keccak256(\"DOMAIN_CHECKPOINT_MANAGER\");\n    uint256 public constant MIN_VALIDATORS = 3;\n    /// @dev ID of eoracle chain\n    uint256 internal _eoracleChainId;\n\n    /// @dev BLS library contract\n    IBLS internal _bls;\n\n    /// @dev BN256G2 library contract\n    IBN256G2 internal _bn256G2;\n\n    /// @dev length of validators set\n    uint256 internal _currentValidatorSetLength;\n\n    /// @dev total voting power of the current validators set\n    uint256 internal _totalVotingPower;\n\n    /// @dev current validators set (index => Validator)\n    mapping(uint256 => Validator) internal _currentValidatorSet;\n\n    /// @dev hash (keccak256) of the current validator set\n    bytes32 internal _currentValidatorSetHash;\n\n    /// @dev block number of the last processed block\n    uint256 internal _lastProcessedBlockNumber;\n\n    /// @dev event root of the last processed block\n    bytes32 internal _lastProcessedEventRoot;\n\n    /// @dev address of the feed manager\n    address internal _feedManager;\n\n    /// @dev mapping of allowed senders\n    mapping(address => bool) internal _allowedSenders;\n\n    /**\n     * @dev Allows only the feed manager to call the function\n     */\n    modifier onlyFeedManager() {\n        if (msg.sender != _feedManager) revert CallerIsNotFeedManager();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @param owner Owner of the contract\n     * @param bls_ Address of the BLS library contract\n     * @param bn256G2_ Address of the Bn256G2 library contract\n     * @param eoracleChainId_ Chain ID of the eoracle chain\n     * @param allowedSenders List of allowed senders\n     */\n    function initialize(\n        address owner,\n        IBLS bls_,\n        IBN256G2 bn256G2_,\n        uint256 eoracleChainId_,\n        address[] calldata allowedSenders\n    )\n        external\n        initializer\n    {\n        if (\n            address(bls_) == address(0) || address(bls_).code.length == 0 || address(bn256G2_) == address(0)\n                || address(bn256G2_).code.length == 0\n        ) {\n            revert InvalidAddress();\n        }\n        _eoracleChainId = eoracleChainId_;\n        _bls = bls_;\n        _bn256G2 = bn256G2_;\n        _setAllowedSenders(allowedSenders, true);\n        __Ownable_init(owner);\n    }\n\n    /**\n     * @inheritdoc IEOFeedVerifier\n     */\n    function verify(\n        LeafInput calldata input,\n        Checkpoint calldata checkpoint,\n        uint256[2] calldata signature,\n        bytes calldata bitmap\n    )\n        external\n        onlyFeedManager\n        returns (bytes memory)\n    {\n        _processCheckpoint(checkpoint, signature, bitmap);\n        bytes memory data = _verifyLeaf(input, checkpoint.eventRoot);\n        return data;\n    }\n\n    /**\n     * @inheritdoc IEOFeedVerifier\n     */\n    function batchVerify(\n        LeafInput[] calldata inputs,\n        Checkpoint calldata checkpoint,\n        uint256[2] calldata signature,\n        bytes calldata bitmap\n    )\n        external\n        onlyFeedManager\n        returns (bytes[] memory)\n    {\n        _processCheckpoint(checkpoint, signature, bitmap);\n        return _verifyLeaves(inputs, checkpoint.eventRoot);\n    }\n\n    /**\n     * @inheritdoc IEOFeedVerifier\n     */\n    function setNewValidatorSet(Validator[] calldata newValidatorSet) external onlyOwner {\n        uint256 length = newValidatorSet.length;\n        if (length < MIN_VALIDATORS) revert ValidatorSetTooSmall();\n        // delete the slots of the old validators\n        if (length < _currentValidatorSetLength) {\n            for (uint256 i = length; i < _currentValidatorSetLength; i++) {\n                delete _currentValidatorSet[i];\n            }\n        }\n        _currentValidatorSetLength = length;\n        _currentValidatorSetHash = keccak256(abi.encode(newValidatorSet));\n        uint256 totalPower = 0;\n        for (uint256 i = 0; i < length; i++) {\n            if (newValidatorSet[i]._address == address(0)) revert InvalidAddress();\n            uint256 votingPower = newValidatorSet[i].votingPower;\n            if (votingPower == 0) revert VotingPowerIsZero();\n            totalPower += votingPower;\n            _currentValidatorSet[i] = newValidatorSet[i];\n        }\n        _totalVotingPower = totalPower;\n        emit ValidatorSetUpdated(_currentValidatorSetLength, _currentValidatorSetHash, _totalVotingPower);\n    }\n\n    /**\n     * @inheritdoc IEOFeedVerifier\n     */\n    function setAllowedSenders(address[] calldata senders, bool allowed) external onlyOwner {\n        _setAllowedSenders(senders, allowed);\n    }\n\n    /**\n     * @inheritdoc IEOFeedVerifier\n     */\n    function setFeedManager(address feedManager_) external onlyOwner {\n        if (feedManager_ == address(0)) revert InvalidAddress();\n        _feedManager = feedManager_;\n        emit FeedManagerSet(feedManager_);\n    }\n\n    /**\n     * @notice Set the bn256G2 contract\n     * @param bn256G2_ Address of the BN256G2 contract\n     */\n    function setBN256G2(IBN256G2 bn256G2_) external onlyOwner {\n        if (address(bn256G2_) == address(0) || address(bn256G2_).code.length == 0) {\n            revert InvalidAddress();\n        }\n        _bn256G2 = bn256G2_;\n    }\n\n    /**\n     * @notice Set the BLS contract\n     * @param bls_ Address of the BLS contract\n     */\n    function setBLS(IBLS bls_) external onlyOwner {\n        if (address(bls_) == address(0) || address(bls_).code.length == 0) {\n            revert InvalidAddress();\n        }\n        _bls = bls_;\n    }\n\n    /**\n     * @notice Returns the ID of the eoracle chain.\n     * @return The eoracle chain ID.\n     */\n    function eoracleChainId() external view returns (uint256) {\n        return _eoracleChainId;\n    }\n\n    /**\n     * @notice Returns the BLS contract.\n     * @return The BLS contract.\n     */\n    function bls() external view returns (IBLS) {\n        return _bls;\n    }\n\n    /**\n     * @notice Returns the BN256G2 contract.\n     * @return The BN256G2 contract.\n     */\n    function bn256G2() external view returns (IBN256G2) {\n        return _bn256G2;\n    }\n\n    /**\n     * @notice Returns the length of the current validator set.\n     * @return The number of validators in the current set.\n     */\n    function currentValidatorSetLength() external view returns (uint256) {\n        return _currentValidatorSetLength;\n    }\n\n    /**\n     * @notice Returns the total voting power of the current validator set.\n     * @return The total voting power.\n     */\n    function totalVotingPower() external view returns (uint256) {\n        return _totalVotingPower;\n    }\n\n    /**\n     * @notice Returns the validator at the specified index in the current validator set.\n     * @param index The index of the validator in the current set.\n     * @return The validator at the given index.\n     */\n    function currentValidatorSet(uint256 index) external view returns (Validator memory) {\n        if (index >= _currentValidatorSetLength) revert ValidatorIndexOutOfBounds();\n        return _currentValidatorSet[index];\n    }\n\n    /**\n     * @notice Returns the hash of the current validator set.\n     * @return The hash of the current validator set.\n     */\n    function currentValidatorSetHash() external view returns (bytes32) {\n        return _currentValidatorSetHash;\n    }\n\n    /**\n     * @notice Returns the block number of the last processed block.\n     * @return The last processed block number.\n     */\n    function lastProcessedBlockNumber() external view returns (uint256) {\n        return _lastProcessedBlockNumber;\n    }\n\n    /**\n     * @notice Returns the event root of the last processed block.\n     * @return The last processed event root.\n     */\n    function lastProcessedEventRoot() external view returns (bytes32) {\n        return _lastProcessedEventRoot;\n    }\n\n    /**\n     * @notice Returns the address of the feed manager.\n     * @return The address of the feed manager.\n     */\n    function feedManager() external view returns (address) {\n        return _feedManager;\n    }\n\n    /**\n     * @notice Returns whether the sender is allowed to submit leaves.\n     * @param sender The address of the sender.\n     */\n    function isSenderAllowed(address sender) external view returns (bool) {\n        return _allowedSenders[sender];\n    }\n\n    /**\n     * @notice Function to verify the checkpoint signature\n     * @param checkpoint Checkpoint data\n     * @param signature Aggregated signature of the checkpoint\n     * @param bitmap Bitmap of the validators who signed the checkpoint\n     */\n    function _processCheckpoint(\n        IEOFeedVerifier.Checkpoint calldata checkpoint,\n        uint256[2] calldata signature,\n        bytes calldata bitmap\n    )\n        internal\n    {\n        // if the eventRoot has not changed, we don't need to verify the whole checkpoint again\n        if (checkpoint.eventRoot == _lastProcessedEventRoot) {\n            return;\n        }\n        _verifySignature(checkpoint, signature, bitmap);\n        if (checkpoint.blockNumber > _lastProcessedBlockNumber) {\n            _lastProcessedBlockNumber = checkpoint.blockNumber;\n            _lastProcessedEventRoot = checkpoint.eventRoot;\n        }\n    }\n\n    function _setAllowedSenders(address[] calldata senders, bool allowed) internal {\n        for (uint256 i; i < senders.length; i++) {\n            _allowedSenders[senders[i]] = allowed;\n        }\n    }\n\n    /**\n     * @notice Verify the signature of the checkpoint\n     * @param checkpoint Checkpoint data\n     * @param signature Aggregated signature of the checkpoint\n     * @param bitmap Bitmap of the validators who signed the checkpoint\n     */\n    function _verifySignature(\n        Checkpoint calldata checkpoint,\n        uint256[2] calldata signature,\n        bytes calldata bitmap\n    )\n        internal\n        view\n    {\n        if (checkpoint.eventRoot == bytes32(0)) revert InvalidEventRoot();\n        bytes memory hash = abi.encode(\n            keccak256(\n                // solhint-disable-next-line func-named-parameters\n                abi.encode(\n                    _eoracleChainId,\n                    checkpoint.blockNumber,\n                    checkpoint.blockHash,\n                    checkpoint.blockRound,\n                    checkpoint.epoch,\n                    checkpoint.eventRoot,\n                    _currentValidatorSetHash,\n                    _currentValidatorSetHash\n                )\n            )\n        );\n\n        uint256[2] memory message = _bls.hashToPoint(DOMAIN, hash);\n\n        uint256 length = _currentValidatorSetLength;\n        // slither-disable-next-line uninitialized-local\n        uint256[4] memory aggPubkey;\n        uint256 aggVotingPower = 0;\n        for (uint256 i = 0; i < length; i++) {\n            if (_getValueFromBitmap(bitmap, i)) {\n                if (aggVotingPower == 0) {\n                    aggPubkey = _currentValidatorSet[i].blsKey;\n                } else {\n                    uint256[4] memory blsKey = _currentValidatorSet[i].blsKey;\n                    (aggPubkey[0], aggPubkey[1], aggPubkey[2], aggPubkey[3]) = _bn256G2.ecTwistAdd({\n                        pt1xx: aggPubkey[0],\n                        pt1xy: aggPubkey[1],\n                        pt1yx: aggPubkey[2],\n                        pt1yy: aggPubkey[3],\n                        pt2xx: blsKey[0],\n                        pt2xy: blsKey[1],\n                        pt2yx: blsKey[2],\n                        pt2yy: blsKey[3]\n                    });\n                }\n                aggVotingPower += _currentValidatorSet[i].votingPower;\n            }\n        }\n\n        if (aggVotingPower == 0) revert AggVotingPowerIsZero();\n        if (aggVotingPower <= ((2 * _totalVotingPower) / 3)) revert InsufficientVotingPower();\n\n        (bool callSuccess, bool result) = _bls.verifySingle(signature, aggPubkey, message);\n\n        if (!callSuccess || !result) revert SignatureVerificationFailed();\n    }\n\n    /**\n     * @notice Verify a batch of exits leaves\n     * @param inputs Batch exit inputs for multiple event leaves\n     * @param eventRoot the root this event should belong to\n     * @return Array of the leaf data fields of all submitted leaves\n     */\n    function _verifyLeaves(LeafInput[] calldata inputs, bytes32 eventRoot) internal view returns (bytes[] memory) {\n        uint256 length = inputs.length;\n        bytes[] memory returnData = new bytes[](length);\n        for (uint256 i = 0; i < length; i++) {\n            returnData[i] = _verifyLeaf(inputs[i], eventRoot);\n        }\n        return returnData;\n    }\n\n    /**\n     * @notice Verify for one event\n     * @param input Exit leaf input\n     * @param eventRoot event root the leaf should belong to\n     * @return The leaf data field\n     */\n    function _verifyLeaf(LeafInput calldata input, bytes32 eventRoot) internal view returns (bytes memory) {\n        bytes32 leaf = keccak256(input.unhashedLeaf);\n        if (!leaf.checkMembership(input.leafIndex, eventRoot, input.proof)) {\n            revert InvalidProof();\n        }\n\n        ( /* uint256 id */ , address sender, /* address receiver */, bytes memory data) =\n            abi.decode(input.unhashedLeaf, (uint256, address, address, bytes));\n        if (!_allowedSenders[sender]) {\n            revert SenderNotAllowed(sender);\n        }\n\n        return data;\n    }\n\n    /**\n     * @dev Extracts a boolean value from a specific index in a bitmap.\n     * @param bitmap The bytes array containing the bitmap.\n     * @param index The bit position from which to retrieve the value.\n     * @return bool The boolean value of the bit at the specified index in the bitmap.\n     *              Returns 'true' if the bit is set (1), and 'false' if the bit is not set (0).\n     */\n    function _getValueFromBitmap(bytes calldata bitmap, uint256 index) private pure returns (bool) {\n        uint256 byteNumber = index / 8;\n        // safe to downcast as any value % 8 will always be less than 8\n        uint8 bitNumber = uint8(index % 8);\n\n        if (byteNumber >= bitmap.length) {\n            return false;\n        }\n        // safe to downcast as bitmap[byteNumber] is byte and less than 256\n        return uint8(bitmap[byteNumber]) & (1 << bitNumber) > 0;\n    }\n\n    // slither-disable-next-line unused-state,naming-convention\n    // solhint-disable-next-line ordering\n    uint256[50] private __gap;\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Ownable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "src/interfaces/IEOFeedVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\ninterface IEOFeedVerifier {\n    /**\n     * @dev Leaf input structure\n     * @param leafIndex Index of the leaf\n     * @param unhashedLeaf Unhashed leaf data\n     *         abi encoded (uint256 id, address sender, address receiver, bytes memory data)\n     *              where bytes memory data =  abi encoded (uint16 feedId, uint256 rate, uint256 timestamp)\n     * @param proof Merkle proof of the leaf\n     */\n    struct LeafInput {\n        uint256 leafIndex;\n        bytes unhashedLeaf;\n        bytes32[] proof;\n    }\n\n    /**\n     * @dev Checkpoint structure\n     * @param epoch Epoch number\n     * @param blockNumber Block number\n     * @param eventRoot Event root of the merkle tree\n     * @param blockHash Block hash\n     * @param blockRound Block round\n     */\n    struct Checkpoint {\n        uint256 epoch;\n        uint256 blockNumber;\n        bytes32 eventRoot;\n        bytes32 blockHash;\n        uint256 blockRound;\n    }\n\n    /**\n     * @dev Validator structure\n     * @param _address Validator address\n     * @param blsKey Validator BLS key\n     * @param votingPower Validator voting power\n     */\n    struct Validator {\n        address _address;\n        uint256[4] blsKey;\n        uint256 votingPower;\n    }\n\n    /**\n     * @dev Event emitted when the validator set is updated\n     * @param currentValidatorSetLength Length of the current validator set\n     * @param currentValidatorSetHash Hash of the current validator set\n     * @param totalVotingPower Total voting power of the current validator set\n     */\n    event ValidatorSetUpdated(\n        uint256 currentValidatorSetLength, bytes32 currentValidatorSetHash, uint256 totalVotingPower\n    );\n\n    /**\n     * @dev Event emitted when the feed manager is set\n     * @param feedManager Address of the feed manager\n     */\n    event FeedManagerSet(address feedManager);\n\n    /**\n     * @notice Verifies leaf, processes checkpoint,\n     *          returns leaf data in case if checkpoint is valid and leaf is part of the merkle tree\n     * @param input leaf input data and proof (LeafInput)\n     * @param checkpoint Checkpoint data (Checkpoint)\n     * @param signature Aggregated signature of the checkpoint\n     * @param bitmap Bitmap of the validators who signed the checkpoint\n     * @return leafData Leaf data, abi encoded (uint16 feedId, uint256 rate, uint256 timestamp)\n     */\n    function verify(\n        LeafInput memory input,\n        Checkpoint calldata checkpoint,\n        uint256[2] calldata signature,\n        bytes calldata bitmap\n    )\n        external\n        returns (bytes memory leafData);\n\n    /**\n     * @notice Verifies multiple leaves, processes checkpoint,\n     *          returns leaf data in case if checkpoint is valid and leaves are part of the merkle tree\n     * @param inputs Exit leaves inputs\n     * @param checkpoint Checkpoint data\n     * @param signature Aggregated signature of the checkpoint\n     * @param bitmap Bitmap of the validators who signed the checkpoint\n     */\n    function batchVerify(\n        LeafInput[] memory inputs,\n        Checkpoint calldata checkpoint,\n        uint256[2] calldata signature,\n        bytes calldata bitmap\n    )\n        external\n        returns (bytes[] memory);\n\n    /**\n     * @notice Function to set a new validator set\n     * @param newValidatorSet The new validator set to store\n     */\n    function setNewValidatorSet(Validator[] calldata newValidatorSet) external;\n\n    /**\n     * @notice Sets the address of the feed manager.\n     * @param feedManager_ The address of the new feed manager.\n     */\n    function setFeedManager(address feedManager_) external;\n\n    /**\n     * @notice Sets allowed sender for exit events\n     * @param senders Addresses of the allowed senders\n     * @param allowed Boolean value to set the sender as allowed or not\n     */\n    function setAllowedSenders(address[] calldata senders, bool allowed) external;\n}\n"
    },
    "src/common/Merkle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\n/**\n * @title Merkle\n * @author QEDK\n * @notice Gas optimized verification of proof of inclusion for a leaf in an ordered Merkle tree\n */\n// solhint-disable no-inline-assembly\nlibrary Merkle {\n    /**\n     * @notice checks membership of a leaf in a merkle tree\n     * @param leaf keccak256 hash to check the membership of\n     * @param index position of the hash in the tree\n     * @param rootHash root hash of the merkle tree\n     * @param proof an array of hashes needed to prove the membership of the leaf\n     * @return isMember boolean value indicating if the leaf is in the tree or not\n     */\n    function checkMembership(\n        bytes32 leaf,\n        uint256 index,\n        bytes32 rootHash,\n        bytes32[] calldata proof\n    )\n        internal\n        pure\n        returns (bool isMember)\n    {\n        // slither-disable-next-line assembly\n        assembly (\"memory-safe\") {\n            // if proof is empty, check if the leaf is the root\n            if proof.length {\n                // set end to be the end of the proof array, shl(5, proof.length) is equivalent to proof.length * 32\n                let end := add(proof.offset, shl(5, proof.length))\n                // set iterator to the start of the proof array\n                let i := proof.offset\n                // prettier-ignore\n                // solhint-disable-next-line no-empty-blocks\n                for { } 1 { } {\n                    // if index is odd, leaf slot is at 0x20, else 0x0\n                    let leafSlot := shl(5, and(0x1, index))\n                    // store the leaf at the calculated slot\n                    mstore(leafSlot, leaf)\n                    // store proof element in whichever slot is not occupied by the leaf\n                    //slither-disable-next-line incorrect-exp\n                    mstore(xor(leafSlot, 32), calldataload(i))\n                    // hash the first 64 bytes in memory\n                    leaf := keccak256(0, 64)\n                    // shift index right by 1 bit to divide by 2\n                    index := shr(1, index)\n                    // increment iterator by 32 bytes\n                    i := add(i, 32)\n                    // break if iterator is at the end of the proof array\n                    if iszero(lt(i, end)) { break }\n                }\n            }\n            // checks if the calculated root matches the expected root\n            // then, check if index was zeroed while calculating proof, else an invalid index was provided\n            isMember := and(eq(leaf, rootHash), iszero(index))\n        }\n    }\n}\n"
    },
    "src/interfaces/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                EOFeedManager\n//////////////////////////////////////////////////////////////////////////*/\nerror CallerIsNotWhitelisted(address caller);\nerror MissingLeafInputs();\nerror FeedNotSupported(uint16 feedId);\nerror SymbolReplay(uint16 feedId);\n\n/*//////////////////////////////////////////////////////////////////////////\n                                EOFeedVerifier\n//////////////////////////////////////////////////////////////////////////*/\nerror CallerIsNotFeedManager();\nerror InvalidInput();\nerror InvalidProof();\nerror InvalidAddress();\nerror InvalidEventRoot();\nerror VotingPowerIsZero();\nerror AggVotingPowerIsZero();\nerror InsufficientVotingPower();\nerror SignatureVerificationFailed();\nerror ValidatorIndexOutOfBounds();\nerror ValidatorSetTooSmall();\nerror SenderNotAllowed(address sender);\n\n/*//////////////////////////////////////////////////////////////////////////\n                                EOFeedRegistryAdapter\n//////////////////////////////////////////////////////////////////////////*/\nerror FeedAlreadyExists();\nerror BaseQuotePairExists();\n"
    },
    "src/interfaces/IBLS.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\ninterface IBLS {\n    /**\n     * @notice verifies a single signature\n     * @param signature 64-byte G1 group element (small sig)\n     * @param pubkey 128-byte G2 group element (big pubkey)\n     * @param message message signed to produce signature\n     * @return bool sig verification\n     * @return bool indicating call success\n     */\n    function verifySingle(\n        uint256[2] calldata signature,\n        uint256[4] calldata pubkey,\n        uint256[2] calldata message\n    )\n        external\n        view\n        returns (bool, bool);\n\n    /**\n     * @notice verifies multiple non-aggregated signatures where each message is unique\n     * @param signature 64-byte G1 group element (small sig)\n     * @param pubkeys array of 128-byte G2 group element (big pubkey)\n     * @param messages array of messages signed to produce signature\n     * @return checkResult bool indicating sig verification\n     * @return callSuccess bool indicating call success\n     */\n    function verifyMultiple(\n        uint256[2] calldata signature,\n        uint256[4][] calldata pubkeys,\n        uint256[2][] calldata messages\n    )\n        external\n        view\n        returns (bool checkResult, bool callSuccess);\n\n    /**\n     * @notice verifies an aggregated signature where the same message is signed\n     * @param signature 64-byte G1 group element (small sig)\n     * @param pubkeys array of 128-byte G2 group element (big pubkey)\n     * @param message message signed by all to produce signature\n     * @return checkResult sig verification\n     * @return callSuccess indicating call success\n     */\n    function verifyMultipleSameMsg(\n        uint256[2] calldata signature,\n        uint256[4][] calldata pubkeys,\n        uint256[2] calldata message\n    )\n        external\n        view\n        returns (bool checkResult, bool callSuccess);\n\n    /**\n     * @notice checks if a signature is formatted correctly and valid\n     * @dev will revert if improperly formatted, will return false if invalid\n     * @param signature the BLS signature\n     * @return bool indicating if the signature is valid or not\n     */\n    function isValidSignature(uint256[2] memory signature) external view returns (bool);\n\n    /**\n     * @notice hashes an arbitrary message to a point on the curve\n     * @dev Fouque-Tibouchi Hash to Curve\n     * @param domain domain separator for the hash\n     * @param message the message to map\n     * @return uint256[2] (x,y) point on the curve that the message maps to\n     */\n    function hashToPoint(bytes32 domain, bytes memory message) external view returns (uint256[2] memory);\n\n    /**\n     * @notice hashes an arbitrary message to a field element\n     * @param domain domain separator for the hash\n     * @param messages the messages to map\n     * @return uint256[2] (x,y) point of the field element that the message maps to\n     */\n    function hashToField(bytes32 domain, bytes memory messages) external view returns (uint256[2] memory);\n\n    /**\n     * @notice maps a field element to the curve\n     * @param _x a valid field element\n     * @return p the point on the curve the point is mapped to\n     */\n    function mapToPoint(uint256 _x) external pure returns (uint256[2] memory p);\n\n    /**\n     * @notice checks if point in the finite field Fq (x,y) is on the G1 curve\n     * @param point array with x and y values of the point\n     * @return _isOnCurve bool indicating if the point is on the curve or not\n     */\n    function isOnCurveG1(uint256[2] memory point) external pure returns (bool _isOnCurve);\n\n    /**\n     * @notice checks if point in the finite field Fq (x,y) is on the G2 curve\n     * @param point array with x and y values of the point\n     * @return _isOnCurve bool indicating if the point is on the curve or not\n     */\n    function isOnCurveG2(uint256[4] memory point) external pure returns (bool _isOnCurve);\n\n    /**\n     * @notice pads messages less than 96 bytes to 96 bytes for hashing\n     * @param domain domain separator for the hash\n     * @param message the message to pad\n     * @return bytes the padded message\n     */\n    function expandMsgTo96(bytes32 domain, bytes memory message) external pure returns (bytes memory);\n}\n"
    },
    "src/interfaces/IBN256G2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\ninterface IBN256G2 {\n    function ecTwistAdd(\n        uint256 pt1xx,\n        uint256 pt1xy,\n        uint256 pt1yx,\n        uint256 pt1yy,\n        uint256 pt2xx,\n        uint256 pt2xy,\n        uint256 pt2yx,\n        uint256 pt2yy\n    )\n        external\n        view\n        returns (uint256, uint256, uint256, uint256);\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
      "@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",
      "ds-test/=lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/",
      "erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/",
      "openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/",
      "openzeppelin-foundry-upgrades/=lib/openzeppelin-foundry-upgrades/src/",
      "solidity-stringutils/=lib/openzeppelin-foundry-upgrades/lib/solidity-stringutils/"
    ],
    "optimizer": { "enabled": true, "runs": 10000 },
    "metadata": { "useLiteralContent": false, "bytecodeHash": "none", "appendCBOR": true },
    "outputSelection": {
      "*": {
        "": ["ast"],
        "*": ["abi", "evm.bytecode", "evm.deployedBytecode", "evm.methodIdentifiers", "metadata", "storageLayout"]
      }
    },
    "evmVersion": "paris",
    "viaIR": false,
    "libraries": {}
  }
}
