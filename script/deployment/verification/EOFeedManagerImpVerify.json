{
  "language": "Solidity",
  "sources": {
    "src/EOFeedManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { IEOFeedVerifier } from \"./interfaces/IEOFeedVerifier.sol\";\nimport { IEOFeedManager } from \"./interfaces/IEOFeedManager.sol\";\nimport {\n    InvalidAddress,\n    CallerIsNotWhitelisted,\n    MissingLeafInputs,\n    FeedNotSupported,\n    SymbolReplay,\n    InvalidInput\n} from \"./interfaces/Errors.sol\";\n\n/**\n * @title EOFeedManager\n * @notice The EOFeedManager contract is responsible for receiving feed updates from whitelisted publishers. These\n * updates are verified using the logic in the EOFeedVerifier. Upon successful verification, the feed data is stored in\n * the EOFeedManager and made available for other smart contracts to read. Only supported feed IDs can be published to\n * the feed manager.\n */\ncontract EOFeedManager is IEOFeedManager, OwnableUpgradeable {\n    /// @dev Map of feed id to price feed (feed id => PriceFeed)\n    mapping(uint16 => PriceFeed) internal _priceFeeds;\n\n    /// @dev Map of whitelisted publishers (publisher => is whitelisted)\n    mapping(address => bool) internal _whitelistedPublishers;\n\n    /// @dev Map of supported feeds, (feed id => is supported)\n    mapping(uint16 => bool) internal _supportedFeedIds;\n\n    /// @dev feed verifier contract\n    IEOFeedVerifier internal _feedVerifier;\n\n    /// @dev Allows only whitelisted publishers to call the function\n    modifier onlyWhitelisted() {\n        if (!_whitelistedPublishers[msg.sender]) revert CallerIsNotWhitelisted(msg.sender);\n        _;\n    }\n\n    /// @dev Allows only non-zero addresses\n    modifier onlyNonZeroAddress(address addr) {\n        if (addr == address(0)) revert InvalidAddress();\n        _;\n    }\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initialize the contract with the feed verifier address\n     * @dev The feed verifier contract must be deployed first\n     * @param feedVerifier Address of the feed verifier contract\n     * @param owner Owner of the contract\n     */\n    function initialize(address feedVerifier, address owner) external onlyNonZeroAddress(feedVerifier) initializer {\n        __Ownable_init(owner);\n        _feedVerifier = IEOFeedVerifier(feedVerifier);\n    }\n\n    /**\n     * @notice Set the feed verifier contract address\n     * @param feedVerifier Address of the feed verifier contract\n     */\n    function setFeedVerifier(address feedVerifier) external onlyOwner onlyNonZeroAddress(feedVerifier) {\n        _feedVerifier = IEOFeedVerifier(feedVerifier);\n    }\n\n    /**\n     * @notice Set the supported feeds\n     * @param feedIds Array of feed ids\n     * @param isSupported Array of booleans indicating whether the feed is supported\n     */\n    function setSupportedFeeds(uint16[] calldata feedIds, bool[] calldata isSupported) external onlyOwner {\n        if (feedIds.length != isSupported.length) revert InvalidInput();\n        for (uint256 i = 0; i < feedIds.length; i++) {\n            _supportedFeedIds[feedIds[i]] = isSupported[i];\n        }\n    }\n\n    /**\n     * @inheritdoc IEOFeedManager\n     */\n    function whitelistPublishers(address[] memory publishers, bool[] memory isWhitelisted) external onlyOwner {\n        if (publishers.length != isWhitelisted.length) revert InvalidInput();\n        for (uint256 i = 0; i < publishers.length; i++) {\n            if (publishers[i] == address(0)) revert InvalidAddress();\n            _whitelistedPublishers[publishers[i]] = isWhitelisted[i];\n        }\n    }\n\n    /**\n     * @inheritdoc IEOFeedManager\n     */\n    // Reentrancy is not an issue because _feedVerifier is set by the owner\n    // slither-disable-next-line reentrancy-benign,reentrancy-events\n    function updatePriceFeed(\n        IEOFeedVerifier.LeafInput memory input,\n        IEOFeedVerifier.Checkpoint calldata checkpoint,\n        uint256[2] calldata signature,\n        bytes calldata bitmap\n    )\n        external\n        onlyWhitelisted\n    {\n        bytes memory data = _feedVerifier.verify(input, checkpoint, signature, bitmap);\n        _processVerifiedRate(data, checkpoint.blockNumber);\n    }\n\n    /**\n     * @inheritdoc IEOFeedManager\n     */\n    // Reentrancy is not an issue because _feedVerifier is set by the owner\n    // slither-disable-next-line reentrancy-benign,reentrancy-events\n    function updatePriceFeeds(\n        IEOFeedVerifier.LeafInput[] calldata inputs,\n        IEOFeedVerifier.Checkpoint calldata checkpoint,\n        uint256[2] calldata signature,\n        bytes calldata bitmap\n    )\n        external\n        onlyWhitelisted\n    {\n        if (inputs.length == 0) revert MissingLeafInputs();\n\n        bytes[] memory data = _feedVerifier.batchVerify(inputs, checkpoint, signature, bitmap);\n        for (uint256 i = 0; i < data.length; i++) {\n            _processVerifiedRate(data[i], checkpoint.blockNumber);\n        }\n    }\n\n    /**\n     * @inheritdoc IEOFeedManager\n     */\n    function getLatestPriceFeed(uint16 feedId) external view returns (PriceFeed memory) {\n        return _getLatestPriceFeed(feedId);\n    }\n\n    /**\n     * @inheritdoc IEOFeedManager\n     */\n    function getLatestPriceFeeds(uint16[] calldata feedIds) external view returns (PriceFeed[] memory) {\n        PriceFeed[] memory retVal = new PriceFeed[](feedIds.length);\n        for (uint256 i = 0; i < feedIds.length; i++) {\n            retVal[i] = _getLatestPriceFeed(feedIds[i]);\n        }\n        return retVal;\n    }\n\n    /**\n     * @inheritdoc IEOFeedManager\n     */\n    function isWhitelistedPublisher(address publisher) external view returns (bool) {\n        return _whitelistedPublishers[publisher];\n    }\n\n    /**\n     * @inheritdoc IEOFeedManager\n     */\n    function isSupportedFeed(uint16 feedId) external view returns (bool) {\n        return _supportedFeedIds[feedId];\n    }\n\n    /**\n     * @notice Get the feed verifier contract address\n     * @return Address of the feed verifier contract\n     */\n    function getFeedVerifier() external view returns (IEOFeedVerifier) {\n        return _feedVerifier;\n    }\n\n    /**\n     * @notice Process the verified rate, check and save it\n     * @param data Verified rate data, abi encoded (uint16 feedId, uint256 rate, uint256 timestamp)\n     * @param blockNumber eoracle chain block number\n     */\n    function _processVerifiedRate(bytes memory data, uint256 blockNumber) internal {\n        (uint16 feedId, uint256 rate, uint256 timestamp) = abi.decode(data, (uint16, uint256, uint256));\n        if (!_supportedFeedIds[feedId]) revert FeedNotSupported(feedId);\n        if (_priceFeeds[feedId].timestamp >= timestamp) revert SymbolReplay(feedId);\n        _priceFeeds[feedId] = PriceFeed(rate, timestamp, blockNumber);\n        emit RateUpdated(feedId, rate, timestamp);\n    }\n\n    /**\n     * @notice Get the latest price feed\n     * @param feedId Feed id\n     * @return PriceFeed struct\n     */\n    function _getLatestPriceFeed(uint16 feedId) internal view returns (PriceFeed memory) {\n        if (!_supportedFeedIds[feedId]) revert FeedNotSupported(feedId);\n        return _priceFeeds[feedId];\n    }\n\n    // slither-disable-next-line unused-state,naming-convention\n    // solhint-disable-next-line ordering\n    uint256[50] private __gap;\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Ownable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "src/interfaces/IEOFeedVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\ninterface IEOFeedVerifier {\n    /**\n     * @dev Leaf input structure\n     * @param leafIndex Index of the leaf\n     * @param unhashedLeaf Unhashed leaf data\n     *         abi encoded (uint256 id, address sender, address receiver, bytes memory data)\n     *              where bytes memory data =  abi encoded (uint16 feedId, uint256 rate, uint256 timestamp)\n     * @param proof Merkle proof of the leaf\n     */\n    struct LeafInput {\n        uint256 leafIndex;\n        bytes unhashedLeaf;\n        bytes32[] proof;\n    }\n\n    /**\n     * @dev Checkpoint structure\n     * @param epoch Epoch number\n     * @param blockNumber Block number\n     * @param eventRoot Event root of the merkle tree\n     * @param blockHash Block hash\n     * @param blockRound Block round\n     */\n    struct Checkpoint {\n        uint256 epoch;\n        uint256 blockNumber;\n        bytes32 eventRoot;\n        bytes32 blockHash;\n        uint256 blockRound;\n    }\n\n    /**\n     * @dev Validator structure\n     * @param _address Validator address\n     * @param blsKey Validator BLS key\n     * @param votingPower Validator voting power\n     */\n    struct Validator {\n        address _address;\n        uint256[4] blsKey;\n        uint256 votingPower;\n    }\n\n    /**\n     * @dev Event emitted when the validator set is updated\n     * @param currentValidatorSetLength Length of the current validator set\n     * @param currentValidatorSetHash Hash of the current validator set\n     * @param totalVotingPower Total voting power of the current validator set\n     */\n    event ValidatorSetUpdated(\n        uint256 currentValidatorSetLength, bytes32 currentValidatorSetHash, uint256 totalVotingPower\n    );\n\n    /**\n     * @dev Event emitted when the feed manager is set\n     * @param feedManager Address of the feed manager\n     */\n    event FeedManagerSet(address feedManager);\n\n    /**\n     * @notice Verifies leaf, processes checkpoint,\n     *          returns leaf data in case if checkpoint is valid and leaf is part of the merkle tree\n     * @param input leaf input data and proof (LeafInput)\n     * @param checkpoint Checkpoint data (Checkpoint)\n     * @param signature Aggregated signature of the checkpoint\n     * @param bitmap Bitmap of the validators who signed the checkpoint\n     * @return leafData Leaf data, abi encoded (uint16 feedId, uint256 rate, uint256 timestamp)\n     */\n    function verify(\n        LeafInput memory input,\n        Checkpoint calldata checkpoint,\n        uint256[2] calldata signature,\n        bytes calldata bitmap\n    )\n        external\n        returns (bytes memory leafData);\n\n    /**\n     * @notice Verifies multiple leaves, processes checkpoint,\n     *          returns leaf data in case if checkpoint is valid and leaves are part of the merkle tree\n     * @param inputs Exit leaves inputs\n     * @param checkpoint Checkpoint data\n     * @param signature Aggregated signature of the checkpoint\n     * @param bitmap Bitmap of the validators who signed the checkpoint\n     */\n    function batchVerify(\n        LeafInput[] memory inputs,\n        Checkpoint calldata checkpoint,\n        uint256[2] calldata signature,\n        bytes calldata bitmap\n    )\n        external\n        returns (bytes[] memory);\n\n    /**\n     * @notice Function to set a new validator set\n     * @param newValidatorSet The new validator set to store\n     */\n    function setNewValidatorSet(Validator[] calldata newValidatorSet) external;\n\n    /**\n     * @notice Sets the address of the feed manager.\n     * @param feedManager_ The address of the new feed manager.\n     */\n    function setFeedManager(address feedManager_) external;\n\n    /**\n     * @notice Sets allowed sender for exit events\n     * @param senders Addresses of the allowed senders\n     * @param allowed Boolean value to set the sender as allowed or not\n     */\n    function setAllowedSenders(address[] calldata senders, bool allowed) external;\n}\n"
    },
    "src/interfaces/IEOFeedManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\nimport { IEOFeedVerifier } from \"./IEOFeedVerifier.sol\";\n\ninterface IEOFeedManager {\n    /**\n     * @dev Price feed structure\n     * @param value Price feed value\n     * @param timestamp Price feed timestamp (block timestamp in eoracle chain when price feed rate is aggregated)\n     * @param eoracleBlockNumber eoracle block number\n     */\n    struct PriceFeed {\n        uint256 value;\n        uint256 timestamp;\n        uint256 eoracleBlockNumber;\n    }\n\n    /**\n     * @dev Event emitted when a price feed is updated\n     * @param feedId Feed id\n     * @param rate Price feed value\n     * @param timestamp Price feed timestamp\n     */\n    event RateUpdated(uint16 indexed feedId, uint256 rate, uint256 timestamp);\n\n    /**\n     * @notice Update the price for a feed\n     * @param input A merkle leaf containing price data and its merkle proof\n     * @param checkpoint Checkpoint data containing eoracle chain metadata and the data merkle root\n     * @param signature Aggregated signature of the checkpoint\n     * @param bitmap Bitmap of the validators who signed the checkpoint\n     */\n    function updatePriceFeed(\n        IEOFeedVerifier.LeafInput calldata input,\n        IEOFeedVerifier.Checkpoint calldata checkpoint,\n        uint256[2] calldata signature,\n        bytes calldata bitmap\n    )\n        external;\n\n    /**\n     * @notice Update the price for multiple feeds\n     * @param inputs Array of leafs to prove the price feeds\n     * @param checkpoint Checkpoint data\n     * @param signature Aggregated signature of the checkpoint\n     * @param bitmap Bitmap of the validators who signed the checkpoint\n     */\n    function updatePriceFeeds(\n        IEOFeedVerifier.LeafInput[] calldata inputs,\n        IEOFeedVerifier.Checkpoint calldata checkpoint,\n        uint256[2] calldata signature,\n        bytes calldata bitmap\n    )\n        external;\n\n    /**\n     * @notice Set the whitelisted publishers\n     * @param publishers Array of publisher addresses\n     * @param isWhitelisted Array of booleans indicating whether the publisher is whitelisted\n     */\n    function whitelistPublishers(address[] memory publishers, bool[] memory isWhitelisted) external;\n\n    /**\n     * @notice Get the latest price for a feed\n     * @param feedId Feed id\n     * @return PriceFeed struct\n     */\n    function getLatestPriceFeed(uint16 feedId) external view returns (PriceFeed memory);\n\n    /**\n     * @notice Get the latest price feeds for multiple feeds\n     * @param feedIds Array of feed ids\n     * @return Array of PriceFeed structs\n     */\n    function getLatestPriceFeeds(uint16[] calldata feedIds) external view returns (PriceFeed[] memory);\n\n    /**\n     * @notice Check if a publisher is whitelisted\n     * @param publisher Address of the publisher\n     * @return Boolean indicating whether the publisher is whitelisted\n     */\n    function isWhitelistedPublisher(address publisher) external view returns (bool);\n\n    /**\n     * @notice Check if a feed is supported\n     * @param feedId feed Id to check\n     * @return Boolean indicating whether the feed is supported\n     */\n    function isSupportedFeed(uint16 feedId) external view returns (bool);\n}\n"
    },
    "src/interfaces/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                EOFeedManager\n//////////////////////////////////////////////////////////////////////////*/\nerror CallerIsNotWhitelisted(address caller);\nerror MissingLeafInputs();\nerror FeedNotSupported(uint16 feedId);\nerror SymbolReplay(uint16 feedId);\n\n/*//////////////////////////////////////////////////////////////////////////\n                                EOFeedVerifier\n//////////////////////////////////////////////////////////////////////////*/\nerror CallerIsNotFeedManager();\nerror InvalidInput();\nerror InvalidProof();\nerror InvalidAddress();\nerror InvalidEventRoot();\nerror VotingPowerIsZero();\nerror AggVotingPowerIsZero();\nerror InsufficientVotingPower();\nerror SignatureVerificationFailed();\nerror ValidatorIndexOutOfBounds();\nerror ValidatorSetTooSmall();\nerror SenderNotAllowed(address sender);\n\n/*//////////////////////////////////////////////////////////////////////////\n                                EOFeedRegistryAdapter\n//////////////////////////////////////////////////////////////////////////*/\nerror FeedAlreadyExists();\nerror BaseQuotePairExists();\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [
      "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
      "@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",
      "ds-test/=lib/ds-test/src/",
      "forge-std/=lib/forge-std/src/",
      "erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/",
      "openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/",
      "openzeppelin-contracts/=lib/openzeppelin-contracts/",
      "openzeppelin-foundry-upgrades/=lib/openzeppelin-foundry-upgrades/src/",
      "solidity-stringutils/=lib/openzeppelin-foundry-upgrades/lib/solidity-stringutils/"
    ],
    "optimizer": { "enabled": true, "runs": 10000 },
    "metadata": { "useLiteralContent": false, "bytecodeHash": "none", "appendCBOR": true },
    "outputSelection": {
      "*": {
        "": ["ast"],
        "*": ["abi", "evm.bytecode", "evm.deployedBytecode", "evm.methodIdentifiers", "metadata", "storageLayout"]
      }
    },
    "evmVersion": "paris",
    "viaIR": false,
    "libraries": {}
  }
}
