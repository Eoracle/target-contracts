{"language":"Solidity","sources":{"src/adapters/EOFeedAdapter.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\nimport { IEOFeedManager } from \"../interfaces/IEOFeedManager.sol\";\nimport { IEOFeedAdapter } from \"./interfaces/IEOFeedAdapter.sol\";\nimport { Initializable } from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport { InvalidAddress } from \"../interfaces/Errors.sol\";\n\n/**\n * @title EOFeedAdapter\n * @notice Price feed adapter contract\n */\ncontract EOFeedAdapter is IEOFeedAdapter, Initializable {\n    /// @dev Feed manager contract\n    IEOFeedManager private _feedManager;\n\n    /// @dev Feed version\n    uint256 private _version;\n\n    /// @dev Feed description\n    string private _description;\n\n    // next 2 variables will be packed in 1 slot\n    /// @dev Feed id\n    uint16 private _feedId;\n\n    /// @dev Decimals of the rate\n    uint8 private _decimals;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initialize the contract\n     * @param feedManager The feed manager address\n     * @param feedId Feed id\n     * @param feedDecimals The decimals of the rate\n     * @param feedDescription The description of feed\n     * @param feedVersion The version of feed\n     */\n    function initialize(\n        address feedManager,\n        uint16 feedId,\n        uint8 feedDecimals,\n        string memory feedDescription,\n        uint256 feedVersion\n    )\n        external\n        initializer\n    {\n        if (feedManager == address(0)) revert InvalidAddress();\n        _feedManager = IEOFeedManager(feedManager);\n        _feedId = feedId;\n        _decimals = feedDecimals;\n        _description = feedDescription;\n        _version = feedVersion;\n    }\n\n    /**\n     * @notice Get the price for the round\n     * @param\n     * @return roundId The round id\n     * @return answer The price\n     * @return startedAt The timestamp of the start of the round\n     * @return updatedAt The timestamp of the end of the round\n     * @return answeredInRound The round id in which the answer was computed\n     */\n    function getRoundData(uint80) external view returns (uint80, int256, uint256, uint256, uint80) {\n        IEOFeedManager.PriceFeed memory priceData = _feedManager.getLatestPriceFeed(_feedId);\n        return (\n            uint80(priceData.eoracleBlockNumber),\n            int256(priceData.value),\n            priceData.timestamp,\n            priceData.timestamp,\n            uint80(priceData.eoracleBlockNumber)\n        );\n    }\n\n    /**\n     * @notice Get the latest price\n     * @return roundId The round id\n     * @return answer The price\n     * @return startedAt The timestamp of the start of the round\n     * @return updatedAt The timestamp of the end of the round\n     * @return answeredInRound The round id in which the answer was computed\n     */\n    function latestRoundData() external view returns (uint80, int256, uint256, uint256, uint80) {\n        IEOFeedManager.PriceFeed memory priceData = _feedManager.getLatestPriceFeed(_feedId);\n        return (\n            uint80(priceData.eoracleBlockNumber),\n            int256(priceData.value),\n            priceData.timestamp,\n            priceData.timestamp,\n            uint80(priceData.eoracleBlockNumber)\n        );\n    }\n\n    /**\n     * @notice Get the latest price\n     * @return int256 The price\n     */\n    function latestAnswer() external view returns (int256) {\n        IEOFeedManager.PriceFeed memory priceData = _feedManager.getLatestPriceFeed(_feedId);\n        return int256(priceData.value);\n    }\n\n    /**\n     * @notice Get the latest timestamp\n     * @return uint256 The timestamp\n     */\n    function latestTimestamp() external view returns (uint256) {\n        IEOFeedManager.PriceFeed memory priceData = _feedManager.getLatestPriceFeed(_feedId);\n        return priceData.timestamp;\n    }\n\n    /**\n     * @notice Get the price for the round (round is not used, the latest price is returned)\n     * @param\n     * @return int256 The price\n     */\n    function getAnswer(uint256) external view returns (int256) {\n        IEOFeedManager.PriceFeed memory priceData = _feedManager.getLatestPriceFeed(_feedId);\n        return int256(priceData.value);\n    }\n\n    /**\n     * @notice Get the timestamp for the round (round is not used, the latest timestamp is returned)\n     * @param\n     * @return uint256 The timestamp\n     */\n    function getTimestamp(uint256) external view returns (uint256) {\n        IEOFeedManager.PriceFeed memory priceData = _feedManager.getLatestPriceFeed(_feedId);\n        return priceData.timestamp;\n    }\n\n    /**\n     * @notice Get the id of the feed\n     * @return uint16 The feed id\n     */\n    function getFeedId() external view returns (uint16) {\n        return _feedId;\n    }\n\n    /**\n     * @notice Get the decimals of the rate\n     * @return uint8 The decimals\n     */\n    function decimals() external view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @notice Get the description of the feed\n     * @return string The description\n     */\n    function description() external view returns (string memory) {\n        return _description;\n    }\n\n    /**\n     * @notice Get the version of the feed\n     * @return uint256 The version\n     */\n    function version() external view returns (uint256) {\n        return _version;\n    }\n\n    /**\n     * @notice Get the latest round\n     * @return uint256 The round id, eoracle block number\n     */\n    function latestRound() external view returns (uint256) {\n        IEOFeedManager.PriceFeed memory priceData = _feedManager.getLatestPriceFeed(_feedId);\n        return priceData.eoracleBlockNumber;\n    }\n\n    // slither-disable-next-line unused-state,naming-convention\n    // solhint-disable-next-line ordering\n    uint256[50] private __gap;\n}\n"},"src/interfaces/IEOFeedManager.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\nimport { IEOFeedVerifier } from \"./IEOFeedVerifier.sol\";\n\ninterface IEOFeedManager {\n    /**\n     * @dev Price feed structure\n     * @param value Price feed value\n     * @param timestamp Price feed timestamp (block timestamp in eoracle chain when price feed rate is aggregated)\n     * @param eoracleBlockNumber eoracle block number\n     */\n    struct PriceFeed {\n        uint256 value;\n        uint256 timestamp;\n        uint256 eoracleBlockNumber;\n    }\n\n    /**\n     * @dev Event emitted when a price feed is updated\n     * @param feedId Feed id\n     * @param rate Price feed value\n     * @param timestamp Price feed timestamp\n     */\n    event RateUpdated(uint16 indexed feedId, uint256 rate, uint256 timestamp);\n\n    /**\n     * @notice Update the price for a feed\n     * @param input A merkle leaf containing price data and its merkle proof\n     * @param checkpoint Checkpoint data containing eoracle chain metadata and the data merkle root\n     * @param signature Aggregated signature of the checkpoint\n     * @param bitmap Bitmap of the validators who signed the checkpoint\n     */\n    function updatePriceFeed(\n        IEOFeedVerifier.LeafInput calldata input,\n        IEOFeedVerifier.Checkpoint calldata checkpoint,\n        uint256[2] calldata signature,\n        bytes calldata bitmap\n    )\n        external;\n\n    /**\n     * @notice Update the price for multiple feeds\n     * @param inputs Array of leafs to prove the price feeds\n     * @param checkpoint Checkpoint data\n     * @param signature Aggregated signature of the checkpoint\n     * @param bitmap Bitmap of the validators who signed the checkpoint\n     */\n    function updatePriceFeeds(\n        IEOFeedVerifier.LeafInput[] calldata inputs,\n        IEOFeedVerifier.Checkpoint calldata checkpoint,\n        uint256[2] calldata signature,\n        bytes calldata bitmap\n    )\n        external;\n\n    /**\n     * @notice Set the whitelisted publishers\n     * @param publishers Array of publisher addresses\n     * @param isWhitelisted Array of booleans indicating whether the publisher is whitelisted\n     */\n    function whitelistPublishers(address[] memory publishers, bool[] memory isWhitelisted) external;\n\n    /**\n     * @notice Get the latest price for a feed\n     * @param feedId Feed id\n     * @return PriceFeed struct\n     */\n    function getLatestPriceFeed(uint16 feedId) external view returns (PriceFeed memory);\n\n    /**\n     * @notice Get the latest price feeds for multiple feeds\n     * @param feedIds Array of feed ids\n     * @return Array of PriceFeed structs\n     */\n    function getLatestPriceFeeds(uint16[] calldata feedIds) external view returns (PriceFeed[] memory);\n\n    /**\n     * @notice Check if a publisher is whitelisted\n     * @param publisher Address of the publisher\n     * @return Boolean indicating whether the publisher is whitelisted\n     */\n    function isWhitelistedPublisher(address publisher) external view returns (bool);\n\n    /**\n     * @notice Check if a feed is supported\n     * @param feedId feed Id to check\n     * @return Boolean indicating whether the feed is supported\n     */\n    function isSupportedFeed(uint16 feedId) external view returns (bool);\n}\n"},"src/adapters/interfaces/IEOFeedAdapter.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\n/**\n * @title IEOFeedAdapter\n * @notice Interface for the EOFeedAdapter contract.\n * @dev compatible of AggregatorV3Interface from CL.\n */\ninterface IEOFeedAdapter {\n    // slither-disable-next-line missing-inheritance\n    function initialize(\n        address feedManager,\n        uint16 feedId,\n        uint8 feedDecimals,\n        string memory feedDescription,\n        uint256 feedVersion\n    )\n        external;\n\n    function getFeedId() external view returns (uint16);\n    function decimals() external view returns (uint8);\n    function description() external view returns (string memory);\n    function version() external view returns (uint256);\n\n    // getRoundData and latestRoundData should both raise \"No data present\"\n    // if they do not have data to report, instead of returning unset values\n    // which could be misinterpreted as actual reported values.\n    function getRoundData(uint80 roundId_)\n        external\n        view\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n    function latestRoundData()\n        external\n        view\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n    // v2 interface\n    function latestAnswer() external view returns (int256);\n\n    function latestTimestamp() external view returns (uint256);\n\n    function latestRound() external view returns (uint256);\n\n    function getAnswer(uint256 roundId) external view returns (int256);\n\n    function getTimestamp(uint256 roundId) external view returns (uint256);\n}\n"},"lib/openzeppelin-contracts-upgradeable/contracts/proxy/utils/Initializable.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"},"src/interfaces/Errors.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\n/*//////////////////////////////////////////////////////////////////////////\n                                EOFeedManager\n//////////////////////////////////////////////////////////////////////////*/\nerror CallerIsNotWhitelisted(address caller);\nerror MissingLeafInputs();\nerror FeedNotSupported(uint16 feedId);\nerror SymbolReplay(uint16 feedId);\n\n/*//////////////////////////////////////////////////////////////////////////\n                                EOFeedVerifier\n//////////////////////////////////////////////////////////////////////////*/\nerror CallerIsNotFeedManager();\nerror InvalidInput();\nerror InvalidProof();\nerror InvalidAddress();\nerror InvalidEventRoot();\nerror VotingPowerIsZero();\nerror AggVotingPowerIsZero();\nerror InsufficientVotingPower();\nerror SignatureVerificationFailed();\nerror ValidatorIndexOutOfBounds();\nerror ValidatorSetTooSmall();\nerror SenderNotAllowed(address sender);\n\n/*//////////////////////////////////////////////////////////////////////////\n                                EOFeedRegistryAdapter\n//////////////////////////////////////////////////////////////////////////*/\nerror FeedAlreadyExists();\nerror BaseQuotePairExists();\n"},"src/interfaces/IEOFeedVerifier.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\ninterface IEOFeedVerifier {\n    /**\n     * @dev Leaf input structure\n     * @param leafIndex Index of the leaf\n     * @param unhashedLeaf Unhashed leaf data\n     *         abi encoded (uint256 id, address sender, address receiver, bytes memory data)\n     *              where bytes memory data =  abi encoded (uint16 feedId, uint256 rate, uint256 timestamp)\n     * @param proof Merkle proof of the leaf\n     */\n    struct LeafInput {\n        uint256 leafIndex;\n        bytes unhashedLeaf;\n        bytes32[] proof;\n    }\n\n    /**\n     * @dev Checkpoint structure\n     * @param epoch Epoch number\n     * @param blockNumber Block number\n     * @param eventRoot Event root of the merkle tree\n     * @param blockHash Block hash\n     * @param blockRound Block round\n     */\n    struct Checkpoint {\n        uint256 epoch;\n        uint256 blockNumber;\n        bytes32 eventRoot;\n        bytes32 blockHash;\n        uint256 blockRound;\n    }\n\n    /**\n     * @dev Validator structure\n     * @param _address Validator address\n     * @param blsKey Validator BLS key\n     * @param votingPower Validator voting power\n     */\n    struct Validator {\n        address _address;\n        uint256[4] blsKey;\n        uint256 votingPower;\n    }\n\n    /**\n     * @dev Event emitted when the validator set is updated\n     * @param currentValidatorSetLength Length of the current validator set\n     * @param currentValidatorSetHash Hash of the current validator set\n     * @param totalVotingPower Total voting power of the current validator set\n     */\n    event ValidatorSetUpdated(\n        uint256 currentValidatorSetLength, bytes32 currentValidatorSetHash, uint256 totalVotingPower\n    );\n\n    /**\n     * @dev Event emitted when the feed manager is set\n     * @param feedManager Address of the feed manager\n     */\n    event FeedManagerSet(address feedManager);\n\n    /**\n     * @notice Verifies leaf, processes checkpoint,\n     *          returns leaf data in case if checkpoint is valid and leaf is part of the merkle tree\n     * @param input leaf input data and proof (LeafInput)\n     * @param checkpoint Checkpoint data (Checkpoint)\n     * @param signature Aggregated signature of the checkpoint\n     * @param bitmap Bitmap of the validators who signed the checkpoint\n     * @return leafData Leaf data, abi encoded (uint16 feedId, uint256 rate, uint256 timestamp)\n     */\n    function verify(\n        LeafInput memory input,\n        Checkpoint calldata checkpoint,\n        uint256[2] calldata signature,\n        bytes calldata bitmap\n    )\n        external\n        returns (bytes memory leafData);\n\n    /**\n     * @notice Verifies multiple leaves, processes checkpoint,\n     *          returns leaf data in case if checkpoint is valid and leaves are part of the merkle tree\n     * @param inputs Exit leaves inputs\n     * @param checkpoint Checkpoint data\n     * @param signature Aggregated signature of the checkpoint\n     * @param bitmap Bitmap of the validators who signed the checkpoint\n     */\n    function batchVerify(\n        LeafInput[] memory inputs,\n        Checkpoint calldata checkpoint,\n        uint256[2] calldata signature,\n        bytes calldata bitmap\n    )\n        external\n        returns (bytes[] memory);\n\n    /**\n     * @notice Function to set a new validator set\n     * @param newValidatorSet The new validator set to store\n     */\n    function setNewValidatorSet(Validator[] calldata newValidatorSet) external;\n\n    /**\n     * @notice Sets the address of the feed manager.\n     * @param feedManager_ The address of the new feed manager.\n     */\n    function setFeedManager(address feedManager_) external;\n\n    /**\n     * @notice Sets allowed sender for exit events\n     * @param senders Addresses of the allowed senders\n     * @param allowed Boolean value to set the sender as allowed or not\n     */\n    function setAllowedSenders(address[] calldata senders, bool allowed) external;\n}\n"}},"settings":{"remappings":["@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/","@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/","ds-test/=lib/ds-test/src/","forge-std/=lib/forge-std/src/","erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/","openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/","openzeppelin-contracts/=lib/openzeppelin-contracts/","openzeppelin-foundry-upgrades/=lib/openzeppelin-foundry-upgrades/src/","solidity-stringutils/=lib/openzeppelin-foundry-upgrades/lib/solidity-stringutils/"],"optimizer":{"enabled":true,"runs":10000},"metadata":{"useLiteralContent":false,"bytecodeHash":"none","appendCBOR":true},"outputSelection":{"*":{"":["ast"],"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata","storageLayout"]}},"evmVersion":"paris","viaIR":false,"libraries":{}}}
